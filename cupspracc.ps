%!PS-Adobe-3.0
%%Title: cupspracc.c
%%For: Urs-Jakob
%%Creator: a2ps version 4.14
%%CreationDate: Sun Apr 10 13:14:27 2011
%%BoundingBox: 24 24 571 818
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 12
%%PageOrder: Ascend
%%DocumentMedia: A4 595 842 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-BoldOblique
%%+ font Courier-Oblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black 
%%DocumentSuppliedResources: procset a2ps-a2ps-hdr
%%+ procset a2ps-black+white-Prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontType get 0 eq {
    currentfont /FontMatrix get 3 get
  }{
    currentfont /FontMatrix get 3 get 1000 mul
  } ifelse
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      % <vector> <key> <val>
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def % -

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Get the underline position and thickness if they're defined.
    % Use 1 if they are not defined.
    currentdict /FontInfo 2 copy known
    { get
      /UnderlinePosition 2 copy % <FontInfo> /UP <FontInfo> /UP
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>

      /UnderlineThickness 2 copy % <FontInfo> /UT <FontInfo> /UT
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>
      pop % -
    }{ pop pop
    } ifelse

    currentdict
  end 
} bind def

% composite fonts for ASCII-EUC mixed strings
% Version 1.2 1/31/1990
% Original Ken'ichi HANDA (handa@etl.go.jp)
% Modified Norio Katayama (katayama@rd.nacsis.ac.jp),1998
% Extend & Fix Koji Nakamaru (maru@on.cs.keio.ac.jp), 1999
% Anyone can freely copy, modify, distribute this program.

/copyfont {	% font-dic extra-entry-count  copyfont  font-dic
	1 index maxlength add dict begin
	{	1 index /FID ne 2 index /UniqueID ne and
		{def} {pop pop} ifelse
	} forall
	currentdict
	end
} bind def

/compositefont { % ASCIIFontName EUCFontName RomanScale RomanOffset Rot(T/F) compositefont font
    /RomanRotation exch def
    /RomanOffset exch def
    /RomanScale exch def
    userdict /fixeucfont_dict known not {
	userdict begin
	    /fixeucfont_dict 2 dict begin
		/UpperByteEncoding [
		    16#00 1 16#20 { pop 0 } for
		    16#21 1 16#28 { 16#20 sub } for
		    16#29 1 16#2F { pop 0 } for
		    16#30 1 16#74 { 16#27 sub } for
		    16#75 1 16#FF { pop 0 } for
		] def
	        /LowerByteEncoding [
		    16#00 1 16#A0 { pop /.notdef } for
		    16#A1 1 16#FE { 16#80 sub 16 2 string cvrs
				    (cXX) dup 1 4 -1 roll
				    putinterval cvn } for
		    /.notdef
		] def
		currentdict
	    end def
	end
    } if
    findfont dup /FontType get 0 eq {
	14 dict begin
	    %
	    % 7+8 bit EUC font
	    %
	    12 dict begin
		/EUCFont exch def
		/FontInfo (7+8 bit EUC font) readonly def
		/PaintType 0 def
		/FontType 0 def
		/FontMatrix matrix def
		% /FontName
		/Encoding fixeucfont_dict /UpperByteEncoding get def
		/FMapType 2 def
		EUCFont /WMode known
		{ EUCFont /WMode get /WMode exch def }
		{ /WMode 0 def } ifelse
		/FDepVector [
		    EUCFont /FDepVector get 0 get
		    [ 16#21 1 16#28 {} for 16#30 1 16#74 {} for ]
		    {
			13 dict begin
			    /EUCFont EUCFont def
			    /UpperByte exch 16#80 add def	
			    % /FontName
			    /FontInfo (EUC lower byte font) readonly def
			    /PaintType 0 def
			    /FontType 3 def
			    /FontMatrix matrix def
			    /FontBBox {0 0 0 0} def
			    /Encoding
				fixeucfont_dict /LowerByteEncoding get def
			    % /UniqueID
			    % /WMode
			    /BuildChar {
				gsave
				exch dup /EUCFont get setfont
				/UpperByte get
				2 string
				dup 0 4 -1 roll put
				dup 1 4 -1 roll put
				dup stringwidth setcharwidth
				0 0 moveto show
				grestore
			    } bind def
			    currentdict
			end
			/lowerbytefont exch definefont
		    } forall
		] def
		currentdict
	    end
	    /eucfont exch definefont
	    exch
	    findfont 1 copyfont dup begin
		RomanRotation {
			/FontMatrix FontMatrix
			[ 0 RomanScale neg RomanScale 0 RomanOffset neg 0 ]
			matrix concatmatrix def
		}{
			/FontMatrix FontMatrix
			[ RomanScale 0 0 RomanScale 0 RomanOffset ] matrix concatmatrix
			def
			/CDevProc
			    {pop pop pop pop 0 exch -1000 exch 2 div 880} def
		} ifelse
	    end
	    /asciifont exch definefont
	    exch
	    /FDepVector [ 4 2 roll ] def
	    /FontType 0 def
	    /WMode 0 def
	    /FMapType 4 def
	    /FontMatrix matrix def
	    /Encoding [0 1] def
	    /FontBBox {0 0 0 0} def
%	    /FontHeight 1.0 def % XXXX
	    /FontHeight RomanScale 1.0 ge { RomanScale }{ 1.0 } ifelse def
	    /Descent -0.3 def   % XXXX
	    currentdict
	end
	/tmpfont exch definefont
	pop
	/tmpfont findfont
    }{
	pop findfont 0 copyfont
    } ifelse
} def	

/slantfont {	% FontName slant-degree  slantfont  font'
    exch findfont 1 copyfont begin
    [ 1 0 4 -1 roll 1 0 0 ] FontMatrix exch matrix concatmatrix
    /FontMatrix exch def
    currentdict
    end
} def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%BeginResource: procset a2ps-a2ps-hdr 2.0 2
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.95 setgray
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def
%%EndResource
%%BeginResource: procset a2ps-black+white-Prolog 2.0 1

% Function T(ab), jumps to the n-th tabulation in the current line
/T { 
  cw mul x0 add y0 moveto
} bind def

% Function n: move to the next line
/n { %def
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
}  bind def

/S {
  Show
} bind def

/p {
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  false UL
  false BX
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/K {
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/C {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/l {
  false UL
  false BX
  fHelvetica bfs scalefont setfont
  Show
} bind def

/L {
  false UL
  false BX
  fHelvetica-Bold bfs scalefont setfont
  Show 
} bind def

/str{
  false UL
  false BX
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  false UL
  true BX
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%IncludeResource: font Courier-BoldOblique
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 595 def
/sw 842 def
/llx 24 def
/urx 818 def
/ury 571 def
/lly 24 def
/#copies 1 def
/th 15.000000 def
/fnfs 11 def
/bfs 8.005733 def
/cw 4.803440 def

% Dictionary for ISO-8859-1 support
/iso1dict 8 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fCourier-BoldOblique ISO-8859-1Encoding /Courier-BoldOblique reencode_font
  /fCourier-Oblique ISO-8859-1Encoding /Courier-Oblique reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 81.400000 mul
def
/ph
   501.959430 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 0 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1-2) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Pracc as a CUPS backend) c n
( *) N
( * Copyright \(c\) 2007 by Urs-Jakob Ruetschi.) N
( * Use at your own exclusive risk and under the terms of the GNU) N
( * General Public License.  See AUTHORS, COPYRIGHT, and COPYING.) N
( */) N
() p n
(/* TODO) c n
( * 1. Logik in estimate\(\): jobscan mehr gewichten.) N
( * 2. Make private_log\(\) NOT truncate the log file.) N
( * 3. RCS ci -l to get a new \(correct\) version number.) N
( * 4. Check doc/tmpl/main.tmpl: at PHZ, link to cupspracc.html is missing?) N
( */) N
() p n
(static) K
( ) p
(char) k
( rcsid[] = \\) p n
(") S
($Id: cupspracc.c,v 1.16 2009/10/06 19:39:13 ujr Exp ujr $) str
(";) p n
() N
(#include) K
( <assert.h>) p n
(#include) K
( <errno.h>) p n
(#include) K
( <fcntl.h>) p n
(#include) K
( <signal.h>) p n
(#include) K
( <stdarg.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <sys/stat.h>) p n
(#include) K
( <sys/types.h>) p n
(#include) K
( <sys/wait.h>) p n
(#include) K
( <time.h>) p n
(#include) K
( <unistd.h>) p n
(#include) K
( <cups/cups.h>) p n
(#include) K
( <cups/http.h>) p n
(#include) K
( <cups/backend.h>) p n
() N
(#include) K
( ") p
(delay.h) str
(") p n
(#include) K
( ") p
(pracc.h) str
(") p n
(#include) K
( ") p
(print.h) str
(") p n
(#include) K
( ") p
(tai.h) str
(") p n
() N
(#include) K
( ") p
(ps.h) str
(") p n
(#include) K
( ") p
(pjl.h) str
(") p n
() N
(/* Configuration */) c n
() p n
(#define) K
( PRIVATE_LOGFILE ") p
(/var/log/cups/pracc) str
(" ) p
(// XXX) c n
() p n
(#define) K
( DEFLT_WAIT0_PS 20    ) p
(/* pause before first pc probe */) c n
(#define) K
( DEFLT_WAIT1_PS 10    ) p
(/* pause between more pc probes */) c n
(#define) K
( DEFLT_WAIT0_PJL 300  ) p
(/* timeout for first PJL reply */) c n
(#define) K
( DEFLT_WAIT1_PJL 120  ) p
(/* timeout for subsequent replies */) c n
() p n
(#define) K
( SHELL ") p
(/bin/sh) str
("      ) p
(/* Used to launch the job scanner */) c n
() p n
(/* Type definitions */) c n
() p n
(typedef) K
( ) p
(enum) k
( {                 ) p
(// How to do accounting:) c n
(   NONE = 0,                   ) p
(// no accounting) c n
(   POSTSCRIPT = 1,             ) p
(// use PostScript commands) c n
(   PJL = 2,                    ) p
(// use PJL JOB/EOJ and PAGE) c n
(   JOBSCAN = 3                 ) p
(// just scan print job) c n
(} mode;) p n
() N
(enum) k
( {                         ) p
(// States of a PJL job:) c n
(cupspracc.c) (Page 1/23) (Mar 15, 11 22:10) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   PJLINIT = 0,                ) p
(// initial state) c n
(   PJLSYNC,                    ) p
(// after @PJL ECHO with our cookie) c n
(   PJLJOB,                     ) p
(// after "our" @PJL USTATUS JOB) c n
(   PJLDONE                     ) p
(// after "our" @PJL USTATUS EOJ) c n
(};) p n
() N
(/* Global variables */) c n
() p n
(int) k
( pagecost = 0;              ) p
(// cost per printed page) c n
(mode acctmode = NONE;          ) p
(// no accounting by default) c n
(int) k
( wait0 = -1, wait1 = -1;    ) p
(// delays waiting for page ejects) c n
(const) K
( ) p
(char) k
( *jobscan = 0;       ) p
(// optional job page scanner) c n
() p n
(const) K
( ) p
(char) k
( *acctname;          ) p
(// name of account to charge) c n
(//const char *jobuser;           // an alias for main's argv[2]) N
(char) k
( jobuser[MAXNAME];         ) p
(// job user taken from argv[2]) c n
(char) k
( jobtitle[48];             ) p
(// job title taken from argv[3]) c n
(const) K
( ) p
(char) k
( *printer;           ) p
(// printer name \(not hostname\)) c n
(long) k
( pages = -1;               ) p
(// num pages printed by printer) c n
(long) k
( pagecount = -1;           ) p
(// printer's pagecount register) c n
(long) k
( jobid = -1;               ) p
(// job id number: atoi\(argv[1]\)) c n
(long) k
( jobpages = -1;            ) p
(// num pages in print job) c n
() p n
(int) k
( cookie;                    ) p
(// for message authentication) c n
(int) k
( pcpending;                 ) p
(// 1 if pending PS pc message) c n
(int) k
( pjlstate;                  ) p
(// state for PJL job; see pjlinput\(\)) c n
() p n
(int) k
( jobfd;                     ) p
(// print job's file descriptor) c n
(int) k
( devfd;                     ) p
(// printer's file descriptor) c n
() p n
(char) k
( hostname[1024];           ) p
(// where to connect to,) c n
(char) k
( portname[256];            ) p
(//  to what service \(port name/num\),) c n
(char) k
( username[256];            ) p
(//  and as what user) c n
() p n
(/* Prototypes */) c n
() p n
(void) k
( parseURI\() p
(const) K
( ) p
(char) k
( *deviceURI\);) p n
(mode parseMode\() S
(const) K
( ) p
(char) k
( *value, mode deflt\);) p n
(int) k
( parseOnOff\() p
(const) K
( ) p
(char) k
( *value, ) p
(int) k
( deflt\);) p n
() N
(void) k
( parseinput\() p
(const) K
( ) p
(char) k
( *buf, ) p
(unsigned) k
( len\);) p n
(void) k
( pjlinput\() p
(const) K
( ) p
(char) k
( *buf, ) p
(unsigned) k
( len\);) p n
(void) k
( psinput\() p
(const) K
( ) p
(char) k
( *buf, ) p
(unsigned) k
( len\);) p n
() N
(int) k
( copyuser\() p
(char) k
( *dest, ) p
(int) k
( size, ) p
(const) K
( ) p
(char) k
( *s\);) p n
(int) k
( copytitle\() p
(char) k
( *dest, ) p
(int) k
( size, ) p
(const) K
( ) p
(char) k
( *s\);) p n
(void) k
( checkaccess\() p
(const) K
( ) p
(char) k
( *username, ) p
(const) K
( ) p
(char) k
( *acctname\);) p n
(long) k
( sendjob\() p
(int) k
( jobfd, ) p
(int) k
( devfd\);) p n
(long) k
( runscan\() p
(int) k
( fd, ) p
(const) K
( ) p
(char) k
( *scanprog\);) p n
(long) k
( estimate\() p
(long) k
( m, ) p
(long) k
( n\);) p n
(void) k
( acctstr\() p
(char) k
( *buf, ) p
(int) k
( maxlen\);) p n
(int) k
( logpc\() p
(long) k
( pc, ) p
(const) K
( ) p
(char) k
( *printer\);) p n
() N
(int) k
( writeall\() p
(int) k
( fd, ) p
(const) K
( ) p
(char) k
( *buf, ) p
(unsigned) k
( len\);) p n
(ssize_t writen\() S
(int) k
( fd, ) p
(const) K
( ) p
(void) k
( *buf, size_t len\);) p n
(int) k
( fdblocking\() p
(int) k
( fd\);) p n
(int) k
( fdnonblock\() p
(int) k
( fd\);) p n
() N
(char) k
( *cupsGetJobBilling\() p
(const) K
( ) p
(char) k
( *printer, ) p
(long) k
( jobid\);) p n
() N
(void) k
( log_page\() p
(long) k
( number, ) p
(long) k
( copies\);   ) p
(// PAGE: ...) c n
(void) k
( log_state\() p
(const) K
( ) p
(char) k
( *s\);             ) p
(// STATE: ...) c n
(cupspracc.c) (Page 2/23) (Mar 15, 11 22:10) title
border
grestore
(Printed by Urs-Jakob) rhead
(cupspracc.c) (1/12) (Sunday April 10, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(void) k
( log_debug\() p
(const) K
( ) p
(char) k
( *fmt, ...\);      ) p
(// DEBUG: ...) c n
(void) k
( log_info\() p
(const) K
( ) p
(char) k
( *fmt, ...\);       ) p
(// INFO: ...) c n
(void) k
( log_error\() p
(const) K
( ) p
(char) k
( *fmt, ...\);      ) p
(// ERROR: ...) c n
(void) k
( die\() p
(int) k
( code, ) p
(const) K
( ) p
(char) k
( *fmt, ...\);  ) p
(// error & exit) c n
(void) k
( cancel\() p
(int) k
( signo\);) p n
() N
(/*) c n
( * Usage: printer-uri job-id user title copies options [file]) N
( */) N
(int) k
( main\() p
(int) k
( argc, ) p
(char) k
( *argv[], ) p
(char) k
( *envp[]\)) p n
({) N
(   ) S
(const) K
( ) p
(char) k
( *devuri;         ) p
(// printer's device URI) c n
(   ) p
(int) k
( copies;                 ) p
(// num of copies to print) c n
(   http_addrlist_t *addrlist;  ) p
(// list of resolved addrs) c n
(   http_addrlist_t *connaddr;  ) p
(// the chosen address) c n
(   ) p
(char) k
( buf[256];              ) p
(// general-purpose buffer) c n
(   ) p
(int) k
( i;                      ) p
(// all-purpose counter) c n
() p n
(   ) S
(/*) c n
(    * Preparation:) N
(    * Make sure that status messages are shipped out unbuffered!) N
(    * Ignore SIGPIPE \(we still get errno = EPIPE\); see also) N
(    *  http://www.developerweb.net/forum/showthread.php?t=2953) N
(    * Catch common signals to terminate in an orderly fashion.) N
(    */) N
() p n
(   setbuf\(stderr, ) S
(NULL) K
(\);) p n
() N
(   ) S
(if) K
( \(signal\(SIGPIPE, SIG_IGN\) < 0\)) p n
(      die\(CUPS_BACKEND_FAILED, ") S
(signal) str
("\);) p n
(   ) S
(if) K
( \(signal\(SIGINT, cancel\) < 0\)) p n
(      die\(CUPS_BACKEND_FAILED, ") S
(signal) str
("\);) p n
(   ) S
(if) K
( \(signal\(SIGQUIT, cancel\) < 0\)) p n
(      die\(CUPS_BACKEND_FAILED, ") S
(signal) str
("\);) p n
(   ) S
(if) K
( \(signal\(SIGTERM, cancel\) < 0\)) p n
(      die\(CUPS_BACKEND_FAILED, ") S
(signal) str
("\);) p n
() N
(   ) S
(/*) c n
(    * Device discovery:) N
(    * If invoked with no arguments, backends should list) N
(    * all supported/detected printer devices to stdout or) N
(    * at least tell what types of printers are supported.) N
(    * We currently only do the latter...) N
(    */) N
() p n
(   ) S
(if) K
( \(argc == 1\) {) p n
(      ) S
(char) k
( *s = strrchr\(argv[0], ') p
(/) str
('\);) p n
(      ) S
(if) K
( \(s == ) p
(NULL) K
(\) s = argv[0]; ) p
(else) K
( ++s;) p n
(      printf\(") S
(network %s \\"Unknown\\" \\"AppSocket/JetDirect w/Acct\\"\\n) str
(", s\);) p n
(      ) S
(return) K
( CUPS_BACKEND_OK;) p n
(   }) N
() N
(   ) S
(/*) c n
(    * Backends are invoked with 6 or 7 arguments:) N
(    * The optional 7th argument is the file to print and defaults) N
(    * to stdin. Complain if not 6 or 7 arguments were supplied.) N
(    */) N
() p n
(   ) S
(switch) K
( \(argc\) {) p n
(   ) S
(case) K
( 6: ) p
(// filtered printing) c n
(      jobfd = 0; ) p
(// print stdin) c n
(      copies = 1; ) p
(// cannot repeat) c n
(cupspracc.c) (Page 3/23) (Mar 15, 11 22:10) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      ) p
(break) K
(;) p n
(   ) S
(case) K
( 7: ) p
(// raw printing) c n
(      ) p
(if) K
( \(\(jobfd = open\(argv[6], O_RDONLY\)\) < 0\)) p n
(         die\(CUPS_BACKEND_FAILED, ") S
(open %s) str
(", argv[6]\);) p n
(      copies = atoi\(argv[4]\);) N
(      ) S
(break) K
(;) p n
(   ) S
(default) K
(:) p n
(      fprintf\(stderr,) N
(         ") S
(Usage: %s job-id user title copies options [file]\\n) str
(", argv[0]\);) p n
(      ) S
(return) K
( CUPS_BACKEND_FAILED;) p n
(   }) N
() N
(   jobid = atoi\(argv[1]\);) N
(   ) S
(//jobuser = argv[2]; // 2009-08-22 copyuser\(\): lower case) c n
(   copyuser\(jobuser, ) p
(sizeof) K
(\(jobuser\), argv[2]\);) p n
(   copytitle\(jobtitle, ) S
(sizeof) K
(\(jobtitle\), argv[3]\);) p n
() N
(   printer = getenv\(") S
(PRINTER) str
("\);) p n
(   ) S
(if) K
( \(printer == ) p
(NULL) K
(\) printer = hostname;) p n
() N
(   ) S
(/*) c n
(    * Parse the device URI into its constituents and) N
(    * store them in global variables for easy access.) N
(    *) N
(    * Note that cupsBackendDeviceURI\(\) is essentially an abbreviation) N
(    * for this: \(devuri = getenv\("DEVICE_URI"\) ? devuri : argv[0]\)) N
(    */) N
() p n
(   devuri = cupsBackendDeviceURI\(argv\);) N
(   ) S
(if) K
( \(devuri\) parseURI\(devuri\);) p n
(   ) S
(else) K
( {) p n
(      errno = 0;) N
(      log_error\(") S
(no device URI specified!) str
("\);) p n
(      ) S
(return) K
( CUPS_BACKEND_STOP;) p n
(   }) N
() N
(   ) S
(/*) c n
(    * The pracc backend is now ready to do its actual work:) N
(    * check credits, send the print job, and do accounting.) N
(    */) N
() p n
(   log_debug\(") S
(This is cupspracc, $Revision: 1.16 $) str
("\);) p n
(   log_debug\(") S
(Job %d user=%s title=%s) str
(", jobid, jobuser, jobtitle\);) p n
(   log_debug\(") S
(DeviceURI: %s) str
(", devuri\);) p n
(   log_debug\(") S
(Parameter: acctmode=%d pagecost=%d wait0=%d wait1=%d) str
(",) p n
(      acctmode, pagecost, wait0, wait1\);) N
(   log_debug\(") S
(Running as: uid=%d euid=%d gid=%d egid=%d pid=%d) str
(",) p n
(      getuid\(\), geteuid\(\), getgid\(\), getegid\(\), getpid\(\)\);) N
() N
(   ) S
(/*) c n
(    * Run the optional job scanner and set jobpages accordingly.) N
(    * For filtered jobs, copy stdin to a temporary file and then) N
(    * work with that file, both for job scanning and printing.) N
(    */) N
() p n
(   ) S
(if) K
( \(jobscan\) {) p n
(      ) S
(if) K
( \(jobfd == 0\) {) p n
(         ) S
(char) k
( fn[256];) p n
(         ) S
(char) k
( buf[16384];) p n
(         ) S
(int) k
( fd;) p n
(         ssize_t n;) N
() N
(cupspracc.c) (Page 4/23) (Mar 15, 11 22:10) title
border
grestore
(Printed by Urs-Jakob) rhead
(cupspracc.c) (2/12) (Sunday April 10, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(         ) p
(if) K
( \(\(fd = cupsTempFd\(fn, ) p
(sizeof) K
(\(fn\)\)\) < 0\)) p n
(            die\(CUPS_BACKEND_FAILED, ") S
(cupsTempFd failed) str
("\);) p n
(         ) S
(if) K
( \(unlink\(fn\) < 0\)) p n
(            die\(CUPS_BACKEND_FAILED, ") S
(unlink failed) str
("\);) p n
() N
(         log_debug\(") S
(Copying stdin to %s) str
(", fn\);) p n
(         ) S
(do) K
( {) p n
(            n = read\(jobfd, buf, ) S
(sizeof) K
(\(buf\)\);) p n
(            ) S
(if) K
( \(n > 0\) ) p
(if) K
( \(writen\(fd, buf, n\) < 0\)) p n
(               die\(CUPS_BACKEND_FAILED, ") S
(write %s failed) str
("\);) p n
(         }) N
(         ) S
(while) K
( \(n > 0\);) p n
(         ) S
(if) K
( \(n < 0\) die\(CUPS_BACKEND_FAILED, ") p
(read failed) str
("\);) p n
() N
(         ) S
(if) K
( \(lseek\(fd, 0, SEEK_SET\) != 0\) ) p
(// rewind) c n
(            die\(CUPS_BACKEND_FAILED, ") p
(lseek on temp file failed) str
("\);) p n
() N
(         jobfd = fd;) N
(      }) N
() N
(      jobpages = runscan\(jobfd, jobscan\);) N
(      ) S
(if) K
( \(lseek\(jobfd, 0, SEEK_SET\) != 0\) ) p
(// rewind) c n
(         die\(CUPS_BACKEND_FAILED, ") p
(lseek on jobfd failed) str
("\);) p n
(   }) N
(   ) S
(else) K
( jobpages = -1; ) p
(// unknown) c n
() p n
(   ) S
(/** Check credits **/) c n
() p n
(   ) S
(if) K
( \(acctmode\) {) p n
(      ) S
(long) k
( balance, limit;) p n
() N
(      acctname = cupsGetJobBilling\(printer, jobid\);) N
(      ) S
(if) K
( \(praccCheckName\(acctname\) < 0\) acctname = jobuser;) p n
(      ) S
(if) K
( \(praccCheckName\(acctname\) < 0\) ) p
(// give up) c n
(         die\(CUPS_BACKEND_CANCEL, ") p
(invalid job user name) str
("\);) p n
() N
(      log_debug\(") S
(Check access: user %s to account %s) str
(", jobuser, acctname\);) p n
(      checkaccess\(jobuser, acctname\); ) S
(// die if access denied) c n
() p n
(      ) S
(if) K
( \(praccSum\(acctname, &balance, &limit, 0, 0, 0\) < 0\) {) p n
(         ) S
(if) K
( \(errno == ENOENT\) { ) p
(// no such account) c n
(            ) p
(if) K
( \(praccSum\(PRACCDEFLT, &balance, &limit, 0, 0, 0\) < 0\) {) p n
(               log_error\(") S
(no account to bill \(requested: %s\)) str
(", acctname\);) p n
(               ) S
(return) K
( CUPS_BACKEND_FAILED;) p n
(            }) N
(            ) S
(else) K
( acctname = PRACCDEFLT;) p n
(         }) N
(         ) S
(else) K
( {) p n
(            log_error\(") S
(error reading account %s) str
(", acctname\);) p n
(            ) S
(return) K
( CUPS_BACKEND_FAILED;) p n
(         }) N
(      }) N
() N
(      ) S
(/* Here: acctname & balance & limit are set */) c n
() p n
(      ) S
(if) K
( \(limit == UNLIMITED\) strcpy\(buf, ") p
(none) str
("\);) p n
(      ) S
(else) K
( sprintf\(buf, ") p
(%ld) str
(", limit\); ) p
(// limited) c n
(      log_info\(") p
(account %s: balance %ld limit %s) str
(", acctname, balance, buf\);) p n
(      ) S
(if) K
( \(jobpages > 0\) balance -= jobpages * pagecost;) p n
(      ) S
(if) K
( \(\(balance < limit\) && \(limit != UNLIMITED\)\) {) p n
(         log_error\(") S
(account %s: insufficient funds) str
(", acctname\);) p n
(         ) S
(return) K
( CUPS_BACKEND_OK; ) p
(// XXX _CANCEL ?) c n
(cupspracc.c) (Page 5/23) (Mar 15, 11 22:10) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      }) p n
(   }) N
() N
(   ) S
(/** Connect **/) c n
() p n
(   addrlist = httpAddrGetList\(hostname, AF_UNSPEC, portname\);) N
(   ) S
(if) K
( \(addrlist == ) p
(NULL) K
(\) {) p n
(      log_error\(") S
(Cannot resolve %s) str
(", hostname\);) p n
(      ) S
(return) K
( CUPS_BACKEND_STOP; ) p
(// stop queue!) c n
(   }) p n
() N
(   log_debug\(") S
(connecting to %s port %s...) str
(", hostname, portname\);) p n
(   log_state\(") S
(+connecting-to-device) str
("\);) p n
() N
(   ) S
(while) K
( \(1\) {) p n
(      ) S
(static) K
( ) p
(int) k
( delay = 0;) p n
(      connaddr = httpAddrConnect\(addrlist, &devfd\);) N
(      ) S
(if) K
( \(connaddr == ) p
(NULL) K
(\) {) p n
(         ) S
(int) k
( saverr = errno;) p n
(         devfd = -1;) N
() N
(         ) S
(/*) c n
(          * If the CLASS env var is set, the job was submitted) N
(          * to a class and not to a specific printer. In this) N
(          * case, terminate immediately so that the job can be) N
(          * re-queued on the next available printer in the class.) N
(          */) N
() p n
(         ) S
(if) K
( \(getenv\(") p
(CLASS) str
("\)\) {) p n
(            errno = \(saverr\) ? saverr : ECONNABORTED;) N
(            log_info\(") S
(%s port %s: %s) str
(", hostname, portname, strerror\(errno\)\);) p n
(            sleep\(5\); ) S
(// do not re-queue too rapidly...) c n
(            ) p
(return) K
( CUPS_BACKEND_FAILED;) p n
(         }) N
() N
(         ) S
(/*) c n
(          * Report the error, sleep some seconds, and try again.) N
(          * CUPS backends are required to do this forever...) N
(          *) N
(          * Better:) N
(          * Check what the error is and give up immediately) N
(          * if it is a permanent error, otherwise repeat up) N
(          * to a max number of retries / connection timeout.) N
(          */) N
() p n
(         errno = \(saverr\) ? saverr : ECONNABORTED;) N
(         log_error\(") S
(%s port %s) str
(", hostname, portname\);) p n
() N
(         ) S
(if) K
( \(delay < 60\) delay += 5;) p n
(         log_info\(") S
(retrying in %d seconds) str
(", delay\);) p n
(         sleep\(delay\);) N
(      }) N
(      ) S
(else) K
( ) p
(break) K
(; ) p
(// connected) c n
(   }) p n
() N
(   log_state\(") S
(-connecting-to-device) str
("\);) p n
() N
(#ifdef) K
( AF_INET6) p n
(   ) S
(if) K
( \(connaddr->addr.addr.sa_family == AF_INET6\)) p n
(      log_debug\(") S
(connected to [%s]:%d \(IPv6\)) str
(",) p n
(         httpAddrString\(&connaddr->addr, buf, ) S
(sizeof) K
(\(buf\)\),) p n
(         ntohs\(connaddr->addr.ipv6.sin6_port\)\);) N
(cupspracc.c) (Page 6/23) (Mar 15, 11 22:10) title
border
grestore
(Printed by Urs-Jakob) rhead
(cupspracc.c) (3/12) (Sunday April 10, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (7-8) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   ) p
(else) K n
(#endif) S
( ) p
(// AF_INET6) c n
(      ) p
(if) K
( \(connaddr->addr.addr.sa_family == AF_INET\)) p n
(         log_debug\(") S
(connected to %s:%d \(IPv4\)) str
(",) p n
(            httpAddrString\(&connaddr->addr, buf, ) S
(sizeof) K
(\(buf\)\),) p n
(            ntohs\(connaddr->addr.ipv4.sin_port\)\);) N
() N
(   ) S
(/*) c n
(    * Finally, ignore SIGTERM to ensure the driver can emit) N
(    * a complete page. For raw printing \(no filter, no driver,) N
(    * just the backend\) do NOT ignore SIGTERM for otherwise) N
(    * there is no way to cancel a raw print job.) N
(    */) N
() p n
(   ) S
(if) K
( \(jobfd == 0\) ) p
(// stdin means filtered printing) c n
(      signal\(SIGTERM, SIG_IGN\);) p n
() N
(   ) S
(/** Synchronise **/) c n
() p n
(   srand\(time\(0\) ^ getpid\(\)\);) N
(   cookie = 10000 + \(rand\(\) & 65535\);) N
(  ) N
(   ) S
(if) K
( \(acctmode == POSTSCRIPT\) {) p n
(      psinit\(\);) N
(      ) S
(if) K
( \(pscount\(devfd, cookie\)\)) p n
(         die\(CUPS_BACKEND_FAILED, ") S
(pscount) str
("\);) p n
(      pcpending = 0;) N
(   }) N
() N
(   ) S
(if) K
( \(acctmode == PJL\) {) p n
(      pjlinit\(\);) N
(      ) S
(if) K
( \(pjluel\(devfd\)\) ) p
(// just an UEL) c n
(         die\(CUPS_BACKEND_FAILED, ") p
(pjluel) str
("\);) p n
(      ) S
(if) K
( \(pjlecho\(devfd, cookie\)\) ) p
(// @PJL ECHO cookie) c n
(         die\(CUPS_BACKEND_FAILED, ") p
(pjlecho) str
("\);) p n
(      ) S
(if) K
( \(pjlcount\(devfd\)\) ) p
(// @PJL INFO PAGECOUNT) c n
(         die\(CUPS_BACKEND_FAILED, ") p
(pjlcount) str
("\);) p n
(      ) S
(if) K
( \(pjljob\(devfd, jobid, 0, 0\)\) ) p
(// @PJL JOB ...  \(TODO cookie i/o jobid\)) c n
(         die\(CUPS_BACKEND_FAILED, ") p
(pjljob) str
("\);) p n
(      pjlstate = PJLINIT;) N
(   }) N
() N
(   ) S
(/** Send print job **/) c n
() p n
(   log_info\(") S
(Sending job data...) str
("\);) p n
() N
(   ) S
(for) K
( \(i = 0; i < copies; i++\) {) p n
(      ) S
(long) k
( nbytes;) p n
() N
(      ) S
(if) K
( \(jobfd != 0\) ) p
(// raw printing \(not stdin\)) c n
(         lseek\(jobfd, 0, SEEK_SET\); ) p
(// rewind) c n
() p n
(      nbytes = sendjob\(jobfd, devfd\);) N
() N
(      ) S
(if) K
( \(jobfd != 0 && nbytes >= 0\)) p n
(         log_debug\(") S
(Sent job file: %ld bytes, copy %d/%d) str
(", nbytes, i+1, copies\);) p n
(   }) N
() N
(   ) S
(/** Get job status **/) c n
() p n
(   ) S
(if) K
( \(\(acctmode == PJL\) || \(acctmode == POSTSCRIPT\)\) {) p n
(      ) S
(long) k
( lastpages;) p n
(cupspracc.c) (Page 7/23) (Mar 15, 11 22:10) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      ) p
(struct) k
( timeval timeout;) p n
() N
(      log_info\(") S
(Waiting for printer to finish...) str
("\);) p n
() N
(      ) S
(if) K
( \(acctmode == POSTSCRIPT\) {) p n
(         ) S
(for) K
( \(i = wait0; i > 0; i = sleep\(i\)\);) p n
(         ) S
(if) K
( \(pscount\(devfd, cookie\) < 0\)) p n
(            die\(CUPS_BACKEND_FAILED, ") S
(pscount) str
("\);) p n
(         lastpages = pages-1; ) S
(// -2) c n
(         timeout.tv_sec = wait1;) p n
(      }) N
(      ) S
(else) K
( ) p
(if) K
( \(acctmode == PJL\) {) p n
(         ) S
(if) K
( \(pjleoj\(devfd, jobid\)\) ) p
(// todo cookie instead of jobid) c n
(            die\(CUPS_BACKEND_FAILED, ") p
(pjleoj) str
("\);) p n
(         timeout.tv_sec = wait0;) N
(      }) N
() N
(      ) S
(while) K
( \(1\) {) p n
(         fd_set rfds;) N
(         ) S
(char) k
( buf[1024];) p n
(         ) S
(int) k
( r;) p n
() N
(         ) S
(if) K
( \(fdnonblock\(devfd\) < 0\) ) p
(// non-blocking printer i/o) c n
(            die\(CUPS_BACKEND_STOP, ") p
(cannot set O_NONBLOCK on devfd) str
("\);) p n
() N
(         FD_ZERO\(&rfds\);) N
(         FD_SET\(devfd, &rfds\);) N
(         timeout.tv_usec = 0;) N
() N
(         ) S
(if) K
( \(\(r = select\(devfd+1, &rfds, ) p
(NULL) K
(, ) p
(NULL) K
(, &timeout\)\) > 0\) {) p n
(            ssize_t n = read\(devfd, buf, ) S
(sizeof) K
(\(buf\)\);) p n
(            ) S
(if) K
( \(n > 0\) parseinput\(buf, n\);) p n
(            ) S
(else) K
( {) p n
(               ) S
(if) K
( \(n == 0\) log_debug\(") p
(Printer closed connection) str
("\); ) p
(// EOF) c n
(               ) p
(else) K
( log_debug\(") p
(Reading printer failed: %s) str
(", strerror\(errno\)\);) p n
(               ) S
(break) K
(; ) p
(// nothing more to wait for...) c n
(            }) p n
(         }) N
(         ) S
(else) K
( {) p n
(            ) S
(if) K
( \(r == 0\)) p n
(               log_debug\(") S
(Timeout waiting for printer) str
("\);) p n
(            ) S
(break) K
(; ) p
(// error or timeout: silently give up) c n
(         }) p n
() N
(         ) S
(if) K
( \(acctmode == POSTSCRIPT\) {) p n
(            ) S
(if) K
( \(pcpending && \(pages == lastpages\)\) ) p
(break) K
(;) p n
(            ) S
(if) K
( \(pages > 0\) log_info\(") p
(Pages printed: %d) str
(", pages\);) p n
(            ) S
(for) K
( \(i = wait1; i > 0; i = sleep\(i\)\);) p n
(            ) S
(if) K
( \(pscount\(devfd, cookie\) < 0\)) p n
(               die\(CUPS_BACKEND_FAILED, ") S
(pscount) str
("\);) p n
(            lastpages = pages;) N
(            pcpending = 0;) N
(            timeout.tv_sec = wait1;) N
(         }) N
(         ) S
(else) K
( ) p
(if) K
( \(acctmode == PJL\) {) p n
(            ) S
(if) K
( \(pjlstate == PJLDONE\) ) p
(break) K
(;) p n
(            timeout.tv_sec = wait1;) N
(         }) N
(      } ) S
(// while) c n
(   } ) p
(// if) c n
() p n
(   ) S
(if) K
( \(acctmode == PJL\) {) p n
(cupspracc.c) (Page 8/23) (Mar 15, 11 22:10) title
border
grestore
(Printed by Urs-Jakob) rhead
(cupspracc.c) (4/12) (Sunday April 10, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (9-10) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      ) p
(// Errors, typically broken pipe, are non-fatal here) c n
(      ) p
(// because the printer might closed the connection by now.) c n
(      ) p
(if) K
( \(pjloff\(devfd\)\) log_error\(") p
(pjloff) str
("\);) p n
(      ) S
(if) K
( \(pjluel\(devfd\)\) log_error\(") p
(pjluel) str
("\);) p n
(   }) N
() N
(   close\(devfd\);) N
(   connaddr = 0;) N
(   httpAddrFreeList\(addrlist\);) N
(   ) S
(if) K
( \(jobfd != 0\) close\(jobfd\);) p n
() N
(   ) S
(/** Append Accounting Record **/) c n
() p n
(   ) S
(if) K
( \(acctmode\) {) p n
(      ) S
(int) k
( type;) p n
(      ) S
(char) k
( info[96];) p n
(      ) S
(long) k
( count, amount;) p n
() N
(      ) S
(if) K
( \(jobpages > 0\) jobpages *= copies;) p n
(      count = estimate\(jobpages, pages\);) N
() N
(      ) S
(if) K
( \(count < 0\) {) p n
(         type = ') S
(!) str
('; ) p
(// error: pages unknown) c n
(         amount = 0;) p n
(      }) N
(      ) S
(else) K
( {) p n
(         type = ') S
(-) str
('; ) p
(// debit pages printed) c n
(         amount = count * pagecost;) p n
(      }) N
() N
(      acctstr\(info, ) S
(sizeof) K
( info\);) p n
() N
(      log_info\(") S
(account %s: %c %s) str
(", acctname, type, info\);) p n
(      ) S
(if) K
( \(praccAppend\(acctname, type, amount, jobuser, info\) != 0\) {) p n
(         log_error\(") S
(praccAppend %s failed) str
(", acctname\);) p n
(         ) S
(return) K
( CUPS_BACKEND_STOP; ) p
(// stop queue!) c n
(      }) p n
(   }) N
() N
(   ) S
(/** Append Pagecount Record **/) c n
() p n
(   ) S
(switch) K
( \(logpc\(pagecount, printer\)\) {) p n
(      ) S
(case) K
( 0: ) p
(/* success */) c
( ) p
(break) K
(;) p n
(      ) S
(case) K
( 1: ) p
(/* no pc log */) c
( ) p
(break) K
(;) p n
(      ) S
(default) K
(: log_error\(") p
(logpc failed) str
("\); ) p
(break) K
(;) p n
(   }) N
() N
(   log_info\(") S
(Job done) str
("\);) p n
(   ) S
(return) K
( CUPS_BACKEND_OK;) p n
(}) N
() N
(/*) c n
( * Send print job to printer and handle data sent back) N
( * by printer. This is essentially a select\(\)-loop and) N
( * modelled after the CUPS backend/runloop.c source file.) N
( */) N
(long) k
( sendjob\() p
(int) k
( jobfd, ) p
(int) k
( devfd\)) p n
({) N
(   ) S
(int) k
( nfds;) p n
(   fd_set rfds, wfds;) N
(   ) S
(char) k
( buffer[8192];) p n
(   ) S
(char) k
( *bufptr = buffer;) p n
(cupspracc.c) (Page 9/23) (Mar 15, 11 22:10) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   ) p
(long) k
( bytes = 0, total = 0;) p n
(   ) S
(int) k
( offline = 0, nopaper = 0;) p n
() N
(   ) S
(if) K
( \(fdnonblock\(devfd\) < 0\) ) p
(// want non-blocking printer i/o) c n
(      die\(CUPS_BACKEND_STOP, ") p
(cannot set O_NONBLOCK on devfd) str
("\);) p n
(   ) S
(if) K
( \(fdnonblock\(jobfd\) < 0\) ) p
(// want non-blocking job reading) c n
(      die\(CUPS_BACKEND_STOP, ") p
(cannot set O_NONBLOCK on jobfd) str
("\);) p n
() N
(   nfds = 1 + \(\(jobfd > devfd\) ? jobfd : devfd\);) N
() N
(   ) S
(while) K
( \(1\) {) p n
(      FD_ZERO\(&rfds\);) N
(      ) S
(if) K
( \(bytes == 0\)) p n
(         FD_SET\(jobfd, &rfds\);) N
(      FD_SET\(devfd, &rfds\);) N
() N
(      FD_ZERO\(&wfds\);) N
(      ) S
(if) K
( \(bytes > 0\)) p n
(         FD_SET\(devfd, &wfds\);) N
(      ) N
(      ) S
(if) K
( \(select\(nfds, &rfds, &wfds, ) p
(NULL) K
(, ) p
(NULL) K
(\) < 0\) {) p n
(         log_debug\(") S
(sendjob: select failed: errno=%d) str
(", errno\);) p n
(         ) S
(/* XXX unsure - taken from backend/runloop.c */) c n
(         ) p
(if) K
( \(errno == ENXIO && !offline\) {) p n
(            log_state\(") S
(+offline-error) str
("\);) p n
(            log_info\(") S
(Printer is currently offline) str
("\);) p n
(            offline = 1;) N
(         }) N
(         sleep\(2\);) N
(         ) S
(continue) K
(;) p n
(      }) N
() N
(      ) S
(/* Handle async printer input */) c n
() p n
(      ) S
(if) K
( \(FD_ISSET\(devfd, &rfds\)\) {) p n
(         ) S
(char) k
( mbuf[1024];) p n
(         ssize_t n = read\(devfd, mbuf, ) S
(sizeof) K
(\(mbuf\)\);) p n
(         ) S
(if) K
( \(n > 0\) parseinput\(mbuf, \() p
(int) k
(\) n\);) p n
(         ) S
(else) K
( {) p n
(            ) S
(if) K
( \(n == 0\) log_debug\(") p
(Printer closed connection) str
("\); ) p
(// EOF) c n
(            ) p
(else) K
( log_debug\(") p
(Reading printer failed: %s) str
(", strerror\(errno\)\);) p n
(            ) S
(/* Otherwise ignore these errors */) c n
(         }) p n
(      }) N
() N
(      ) S
(/* Read print job data */) c n
() p n
(      ) S
(if) K
( \(\(bytes == 0\) && FD_ISSET\(jobfd, &rfds\)\) {) p n
(         ssize_t n = read\(jobfd, buffer, ) S
(sizeof) K
(\(buffer\)\);) p n
(         ) S
(if) K
( \(n > 0\) bytes = n;) p n
(         ) S
(else) K
( ) p
(if) K
( \(n < 0\) {) p n
(            ) S
(if) K
( \(errno == EAGAIN || errno == EINTR\)) p n
(               bytes = 0;) N
(            ) S
(else) K
( { ) p
(// all other errors) c n
(               log_error\(") p
(cannot read print job data) str
("\);) p n
(               ) S
(return) K
( -1; ) p
(// see errno) c n
(            }) p n
(         }) N
(         ) S
(else) K
( ) p
(break) K
(; ) p
(// end-of-file, we're done) c n
() p n
(         bufptr = buffer; ) S
(// reset bufptr) c n
(      }) p n
(cupspracc.c) (Page 10/23) (Mar 15, 11 22:10) title
border
grestore
(Printed by Urs-Jakob) rhead
(cupspracc.c) (5/12) (Sunday April 10, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (11-12) 6
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(      ) S
(/* Write job data to printer */) c n
() p n
(      ) S
(if) K
( \(\(bytes > 0\) && FD_ISSET\(devfd, &wfds\)\) {) p n
(         ssize_t n = write\(devfd, bufptr, bytes\);) N
(         ) S
(if) K
( \(n < 0\) ) p
(switch) K
( \(errno\) {) p n
(            ) S
(case) K
( ENOSPC:) p n
(               ) S
(if) K
( \(nopaper\) ) p
(break) K
(;) p n
(               log_error\(") S
(Out of paper!) str
("\);) p n
(               log_state\(") S
(+media-empty-error) str
("\);) p n
(               nopaper = 1;) N
(               ) S
(break) K
(;) p n
(            ) S
(case) K
( ENXIO:) p n
(               ) S
(if) K
( \(offline\) ) p
(break) K
(;) p n
(               log_state\(") S
(+offline-error) str
("\);) p n
(               log_info\(") S
(Printer is offline) str
("\);) p n
(               offline = 1;) N
(               ) S
(break) K
(;) p n
(            ) S
(case) K
( EAGAIN:) p n
(            ) S
(case) K
( EINTR:) p n
(            ) S
(case) K
( ENOTTY:) p n
(               ) S
(break) K
(;) p n
(            ) S
(default) K
(:) p n
(               log_error\(") S
(cannot write printer: %s) str
(", strerror\(errno\)\);) p n
(               ) S
(return) K
( -1;) p n
(         }) N
(         ) S
(else) K
( {) p n
(            ) S
(if) K
( \(nopaper\) {) p n
(               log_state\(") S
(-media-empty-error) str
("\);) p n
(               nopaper = 0;) N
(            }) N
(            ) S
(if) K
( \(offline\) {) p n
(               log_state\(") S
(-offline-error) str
("\);) p n
(               log_info\(") S
(Printer now online) str
("\);) p n
(               offline = 0;) N
(            }) N
() N
(            bytes -= n;) N
(            bufptr += n;) N
(            total += n;) N
(         }) N
(      }) N
(   }) N
() N
(   ) S
(return) K
( total; ) p
(// #bytes sent to printer) c n
(}) p n
() N
(/*) c n
( * Scan the print job on the given fd using the given) N
( * program. This program must read print job data from) N
( * its standard input and write the number of pages the) N
( * job would produce when printed to its standard output.) N
( * Also, it must return status 0 if successful.) N
( *) N
( * I don't use popen/pclose so I get a chance to dup) N
( * the given job fd to stdin between fork and exec.) N
( */) N
(long) k
( runscan\() p
(int) k
( fd, ) p
(const) K
( ) p
(char) k
( *scanprog\)) p n
({) N
(   ) S
(FILE) k
( *scanner;) p n
(   ) S
(char) k
( line[256];) p n
(   ) S
(long) k
( num = -1;) p n
(cupspracc.c) (Page 11/23) (Mar 15, 11 22:10) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   ) p
(int) k
( pfd[2], n;) p n
(   pid_t pid;) N
(   ) S
(int) k
( status;) p n
() N
(   assert\(scanprog\);) N
() N
(   log_debug\(") S
(runscan\(%d, %s\)...) str
(", fd, scanprog\);) p n
() N
(   ) S
(if) K
( \(pipe\(pfd\) < 0\)) p n
(      die\(CUPS_BACKEND_FAILED, ") S
(pipe failed) str
("\);) p n
() N
(   ) S
(if) K
( \(\(pid = fork\(\)\) < 0\)) p n
(      die\(CUPS_BACKEND_FAILED, ") S
(fork failed) str
("\);) p n
() N
(   ) S
(if) K
( \(pid == 0\) { ) p
(// child) c n
(      close\(pfd[0]\);) p n
(      ) S
(if) K
( \(pfd[1] != 1\) {) p n
(         dup2\(pfd[1], 1\);) N
(         close\(pfd[1]\);) N
(      }) N
(      dup2\(fd, 0\);) N
(      close\(3\);) N
(      close\(4\);) N
(      execl\(SHELL, ") S
(sh) str
(", ") p
(-c) str
(", scanprog, \() p
(char) k
( *\) 0\);) p n
(      _exit\(127\);) N
(   }) N
() N
(   close\(pfd[1]\);) N
(   scanner = fdopen\(pfd[0], ") S
(r) str
("\);) p n
(   ) S
(if) K
( \(!scanner\)) p n
(      die\(CUPS_BACKEND_FAILED, ") S
(fdopen failed) str
("\);) p n
() N
(   ) S
(do) K
( {) p n
(      n = getln\(scanner, line, ) S
(sizeof) K
(\(line\), 0\);) p n
(      ) S
(if) K
( \(\(num < 0\) && \(n > 0\)\) {) p n
(         ) S
(const) K
( ) p
(char) k
( *p = line;) p n
(         line[n-1] = ') S
(\\0) str
('; ) p
(// overwrite \\n) c n
(         log_debug\(") p
(Job scanner said: %s$) str
(", p\);) p n
(         ) S
(while) K
( \(isspace\(*p\)\) ++p;) p n
(         scanu\(p, &num\);) N
(      }) N
(   }) N
(   ) S
(while) K
( \(n > 0\);) p n
() N
(   ) S
(if) K
( \(fclose\(scanner\) != 0\)) p n
(      die\(CUPS_BACKEND_FAILED, ") S
(fclose failed) str
("\);) p n
(   ) S
(while) K
( \(waitpid\(pid, &status, 0\) < 0\)) p n
(      ) S
(if) K
( \(errno != EINTR\)) p n
(         die\(CUPS_BACKEND_FAILED, ") S
(waitpid failed) str
("\);) p n
(   ) S
(if) K
( \(status != 0\)) p n
(      die\(CUPS_BACKEND_FAILED, ") S
(%s failed) str
(", scanprog\);) p n
() N
(   ) S
(return) K
( num; ) p
(// jobpages, -1 if unknown) c n
(}) p n
() N
(/*) c n
( * Handle input from the printer:) N
( *) N
( * Look for messages \(PostScript or PJL, depending on) N
( * the acctmode\), parse messages by calling low-level) N
( * routines, and react upon the parsed message code.) N
( */) N
(cupspracc.c) (Page 12/23) (Mar 15, 11 22:10) title
border
grestore
(Printed by Urs-Jakob) rhead
(cupspracc.c) (6/12) (Sunday April 10, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (13-14) 7
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(void) k
( parseinput\() p
(const) K
( ) p
(char) k
( *buf, ) p
(unsigned) k
( len\)) p n
({) N
(   ) S
(char) k
( out[64];) p n
(   ) S
(int) k
( i, n;) p n
() N
(   n = ) S
(sizeof) K
(\(out\) - 1;) p n
(   ) S
(if) K
( \(len < n\) n = len;) p n
(   ) S
(for) K
( \(i = 0; i < n; i++\) {) p n
(      ) S
(register) K
( ) p
(char) k
( c = buf[i];) p n
(      ) S
(if) K
( \(\(c == ') p
( ) str
('\) || isgraph\(c\)\) out[i] = c;) p n
(      ) S
(else) K
( out[i] = ') p
(.) str
(';) p n
(   }) N
(   out[i] = ') S
(\\0) str
(';) p n
() N
(   log_debug\(") S
(Got %d bytes from printer:) str
(", len\);) p n
(   log_debug\(") S
(%s) str
(", out\);) p n
() N
(   cupsBackChannelWrite\(buf, len, 1.0\);) N
() N
(   ) S
(switch) K
( \(acctmode\) {) p n
(   ) S
(case) K
( POSTSCRIPT:) p n
(      psinput\(buf, len\);) N
(      ) S
(break) K
(;) p n
(   ) S
(case) K
( PJL:) p n
(      pjlinput\(buf, len\);) N
(      ) S
(break) K
(;) p n
(   ) S
(default) K
(: ) p
(/* ignore */) c
( ;) p n
(   }) N
(}) N
() N
(void) k
( psinput\() p
(const) K
( ) p
(char) k
( *buf, ) p
(unsigned) k
( len\)) p n
({) N
(   ) S
(register) K
( ) p
(const) K
( ) p
(char) k
( *p = buf;) p n
(   ) S
(const) K
( ) p
(char) k
( *end = buf + len;) p n
() N
(   ) S
(while) K
( \(p < end\) {) p n
(      ) S
(int) k
( t = pschar\(*p++\);) p n
(      ) S
(if) K
( \(t\) ) p
(switch) K
( \(t\) {) p n
(      ) S
(case) K
( PS_MSG_PAGECOUNT:) p n
(         ) S
(if) K
( \(ps_cookie == cookie\) {) p n
(            log_debug\(") S
(psinput: PAGECOUNT %d) str
(", ps_pagecount\);) p n
(            ) S
(if) K
( \(pagecount < 0\)) p n
(               pagecount = ps_pagecount; ) S
(// remember initial pc) c n
(            ) p
(else) K
( ) p
(if) K
( \(ps_pagecount >= pagecount\)) p n
(               pages = ps_pagecount - pagecount;) N
(            pcpending = 1; ) S
(// got valid pc message) c n
(         }) p n
(         ) S
(else) K
( log_debug\(") p
(psinput: got cookie %ld, expected %ld) str
(",) p n
(                    ps_cookie, cookie\);) N
(         ) S
(break) K
(;) p n
(      ) S
(case) K
( PS_MSG_PRERROR:) p n
(         log_error\(") S
(PrinterError: %s) str
(", ps_error\);) p n
(         exit\(CUPS_BACKEND_FAILED\);) N
(         ) S
(break) K
(;) p n
(      ) S
(case) K
( PS_MSG_FLUSHING:) p n
(         log_error\(") S
(Flushing: rest of job will be ignored) str
("\);) p n
(         exit\(CUPS_BACKEND_CANCEL\); ) S
(// cancel job) c n
(         ) p
(break) K
(;) p n
(      }) N
(   }) N
(}) N
() N
(cupspracc.c) (Page 13/23) (Mar 15, 11 22:10) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/*) c n
( * Parse PJL messages and try counting pages printed.) N
( * Use the messages to advance in a simple state diagram:) N
( *) N
( *   INIT---\(1\)-->SYNCED---\(2\)-->INJOB---\(3\)-->DONE) N
( *) N
( * Transitions: \(1\) ECHO with our cookie; \(2\) JOB with) N
( * our cookie; \(3\) EOJ with our cookie.) N
( *) N
( * While INJOB, use all PAGE and EOJ messages to set) N
( * the global pages variable, not just our EOJ message.) N
( * Reason: at least the HP LaserJet 5000 gets the EOJ) N
( * pages wrong for nested JOB/EOJ pairs; to reproduce,) N
( * print a Windows Test Page to an HP LaserJet 5000...) N
( */) N
(void) k
( pjlinput\() p
(const) K
( ) p
(char) k
( *buf, ) p
(unsigned) k
( len\)) p n
({) N
(   ) S
(register) K
( ) p
(const) K
( ) p
(char) k
( *p = buf;) p n
(   ) S
(const) K
( ) p
(char) k
( *end = buf + len;) p n
() N
(   ) S
(while) K
( \(p < end\) {) p n
(      ) S
(int) k
( msg = pjlchar\(*p++\);) p n
(      ) S
(if) K
( \(msg\) ) p
(switch) K
( \(msg\) {) p n
(      ) S
(case) K
( PJL_MSG_COOKIE:) p n
(         ) S
(if) K
( \(pjl_cookie != cookie\) ) p
(break) K
(; ) p
(// not our cookie) c n
(         log_debug\(") p
(pjlinput: state=%d COOKIE %ld \(ok\)) str
(",) p n
(                   pjlstate, pjl_cookie\);) N
(         ) S
(if) K
( \(pjlstate != PJLINIT\) ) p
(break) K
(; ) p
(// ignore unexpected ECHO message) c n
(         pjlstate = PJLSYNC;) p n
(         ) S
(break) K
(;) p n
(      ) S
(case) K
( PJL_MSG_PAGECOUNT:) p n
(         ) S
(if) K
( \(pjlstate != PJLSYNC\) ) p
(break) K
(;) p n
(         log_debug\(") S
(pjlinput: state=%d PAGECOUNT %ld) str
(",) p n
(                   pjlstate, pjl_pagecount\);) N
(         ) S
(if) K
( \(pagecount < 0\) pagecount = pjl_pagecount; ) p
(// only once) c n
(         ) p
(break) K
(;) p n
(      ) S
(case) K
( PJL_MSG_JOBSTART:) p n
(         log_debug\(") S
(pjlinput: state=%d JOB %ld) str
(",) p n
(                   pjlstate, pjl_jobnum\);) N
(         ) S
(if) K
( \(pjlstate != PJLSYNC\) ) p
(break) K
(; ) p
(// out-of-order) c n
(         ) p
(if) K
( \(pjl_jobnum != jobid\) ) p
(break) K
(; ) p
(// not our job \(todo cookie i/o jobid\)) c n
(         pjlstate = PJLJOB;) p n
(         ) S
(break) K
(;) p n
(      ) S
(case) K
( PJL_MSG_JOBEND:) p n
(         log_debug\(") S
(pjlinput: state=%d EOJ %ld %ld) str
(",) p n
(                   pjlstate, pjl_jobnum, pjl_numpages\);) N
(         ) S
(if) K
( \(pjlstate != PJLJOB\) ) p
(break) K
(;) p n
(         ) S
(if) K
( \(pjl_numpages > pages\) pages = pjl_numpages;) p n
(         ) S
(if) K
( \(pjl_jobnum == jobid\) { ) p
(// todo cookie instead of jobid) c n
(            pjlstate = PJLDONE;) p n
(         }) N
(         ) S
(break) K
(;) p n
(      ) S
(case) K
( PJL_MSG_PAGE:) p n
(         log_debug\(") S
(pjlinput: state=%d PAGE %ld) str
(",) p n
(                   pjlstate, pjl_curpage\);) N
(         ) S
(if) K
( \(pjlstate != PJLJOB\) ) p
(break) K
(; ) p
(// ignore outside "our" job) c n
(         ) p
(if) K
( \(pjl_curpage > pages\) pages = pjl_curpage;) p n
(         ) S
(if) K
( \(jobfd != 0\) log_page\(pages, 1\);) p n
(         log_info\(") S
(Printed page %d) str
(", pjl_curpage\);) p n
(         ) S
(break) K
(;) p n
(      }) N
(   }) N
(cupspracc.c) (Page 14/23) (Mar 15, 11 22:10) title
border
grestore
(Printed by Urs-Jakob) rhead
(cupspracc.c) (7/12) (Sunday April 10, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (15-16) 8
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(}) p n
() N
(/*) c n
( * Estimate the number of pages printed, based on the) N
( * number m of pages in the printjob \(-1 if unknown\)) N
( * and the number n of pages printed as reported by) N
( * the printer \(-1 if unknown\).) N
( *) N
( * PJL is much more robust than the PostScript method:) N
( * if acctmode == PJL trust n and don't average with m.) N
( */) N
(long) k
( estimate\() p
(long) k
( m, ) p
(long) k
( n\)) p n
({) N
(   ) S
(if) K
( \(\(m < 0\) && \(n < 0\)\) ) p
(return) K
( -1; ) p
(// unknown) c n
() p n
(   ) S
(if) K
( \(m < 0\) ) p
(return) K
( n;) p n
(   ) S
(if) K
( \(n < 0\) ) p
(return) K
( m;) p n
() N
(   ) S
(if) K
( \(acctmode == PJL\) ) p
(return) K
( n;) p n
(   ) S
(return) K
( \(m < n\) ? n : \(m+n\)/2;) p n
(}) N
() N
(/*) c n
( * Build the accounting info string in the given buffer,) N
( * using information from global variables. The buffer) N
( * should be at least 90 bytes. Account info string format:) N
( *) N
( *   print JID PRINTER JOBPAGES PAGES [JOBTITLE]) N
( *) N
( * JOBPAGES and PAGES are -1 if unknown.) N
( */) N
(void) k
( acctstr\() p
(char) k
( *buf, ) p
(int) k
( maxlen\)) p n
({) N
(   ) S
(register) K
( ) p
(char) k
( *p = buf;) p n
(   p += prints\(p, ") S
(print ) str
("\);) p n
(   p += printu\(p, jobid\);) N
(   p += printc\(p, ') S
( ) str
('\);) p n
(   p += printsn\(p, printer, 30\);) N
(   p += printc\(p, ') S
( ) str
('\);) p n
(   p += printi\(p, jobpages\); ) S
(// -1 if unknown) c n
(   p += printc\(p, ') p
( ) str
('\);) p n
(   p += printi\(p, pages\); ) S
(// -1 if unknown) c n
(   ) p
(if) K
( \(jobtitle && jobtitle[0]\) {) p n
(      p += printc\(p, ') S
( ) str
('\);) p n
(      p += printsn\(p, jobtitle, 30\);) N
(   }) N
(   p += print0\(p\);) N
(}) N
() N
(/*) c n
( * Append a record to the pagecount log file.) N
( *) N
( * The format of pagecount log records is) N
( *) N
( *   @timestamp pagecount printer [comment]) N
( *) N
( * Return 0 if ok, 1 if no pagecount log file,) N
( * and -1 on system errors \(see errno\).) N
( */) N
(int) k
( logpc\() p
(long) k
( pc, ) p
(const) K
( ) p
(char) k
( *printer\)) p n
({) N
(   ) S
(struct) k
( tai now;) p n
(cupspracc.c) (Page 15/23) (Mar 15, 11 22:10) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   ) p
(char) k
( buf[80];) p n
(   ) S
(char) k
( *p, *endp;) p n
(   ) S
(int) k
( fd, len;) p n
() N
(   fd = open\(PRACCPCLOG, O_WRONLY | O_APPEND\);) N
(   ) S
(if) K
( \(fd < 0\) {) p n
(      ) S
(if) K
( \(errno == ENOENT\) ) p
(return) K
( 1; ) p
(// no pc log) c n
(      ) p
(else) K
( ) p
(return) K
( -1; ) p
(// general error, see errno) c n
(   }) p n
() N
(   tainow\(&now\); ) S
(// system time) c n
() p n
(   p = buf;) N
(   endp = buf + ) S
(sizeof) K
( buf - 1;) p n
(   p += taifmt\(p, &now\);) N
(   p += printc\(p, ') S
( ) str
('\);) p n
(   p += printi\(p, pc\);) N
(   p += printc\(p, ') S
( ) str
('\);) p n
(   ) S
(if) K
( \(!printer\) printer = ") p
(unknown) str
(";) p n
(   p += printsn\(p, printer, endp-p\);) N
(   p += printc\(p, ') S
(\\n) str
('\);) p n
() N
(   len = p - buf;) N
(   ) S
(if) K
( \(write\(fd, buf, len\) < 0\) ) p
(return) K
( -1; ) p
(// see errno) c n
(   ) p
(if) K
( \(close\(fd\) < 0\) ) p
(return) K
( -1; ) p
(// see errno) c n
() p n
(   ) S
(return) K
( 0; ) p
(// ok) c n
(}) p n
() N
(/*) c n
( * Parse the device URI into its constituents and) N
( * store them in global variables for easy access.) N
( */) N
(void) k
( parseURI\() p
(const) K
( ) p
(char) k
( *deviceURI\)) p n
({) N
(   ) S
(char) k
( method[256];) p n
(   ) S
(char) k
( resource[1024];) p n
(   ) S
(char) k
( *options;) p n
(   http_uri_status_t result;) N
(   ) S
(const) K
( ) p
(char) k
( *name, *value;) p n
(   ) S
(long) k
( number;) p n
(   ) S
(int) k
( portnum = 0;) p n
() N
(   result = httpSeparateURI\(HTTP_URI_CODING_ALL, deviceURI,) N
(      method, ) S
(sizeof) K
(\(method\), username, ) p
(sizeof) K
(\(username\),) p n
(      hostname, ) S
(sizeof) K
(\(hostname\), &portnum,) p n
(      resource, ) S
(sizeof) K
(\(resource\)\);) p n
() N
(   ) S
(if) K
( \(portnum == 0\) portnum = 9100; ) p
(// default: JetDirect) c n
(   portname[printu\(portname, portnum\)] = ') p
(\\0) str
(';) p n
() N
(   ) S
(if) K
( \(\(options = strchr\(resource, ') p
(?) str
('\)\) != ) p
(NULL) K
(\) {) p n
(      *options++ = ') S
(\\0) str
(';) p n
(      ) S
(while) K
( \(*options\) {) p n
(      name = options;) N
(      ) S
(while) K
( \(*options && *options != ') p
(=) str
(' && *options != ') p
(&) str
('\)) p n
(         ++options;) N
(         value = options++;) N
(         ) S
(if) K
( \(*value == ') p
(=) str
('\) {) p n
(            *\() S
(char) k
(*\)value++ = ') p
(\\0) str
('; ) p
(// overwrite '=' with NUL) c n
(            ) p
(while) K
( \(*options && *options != ') p
(&) str
(' && *options != ') p
(+) str
('\)) p n
(               ++options;) N
(cupspracc.c) (Page 16/23) (Mar 15, 11 22:10) title
border
grestore
(Printed by Urs-Jakob) rhead
(cupspracc.c) (8/12) (Sunday April 10, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (17-18) 9
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(            ) p
(if) K
( \(*options\) *options++ = ') p
(\\0) str
(';) p n
(         }) N
(         ) S
(else) K
( *\() p
(char) k
(*\)value = ') p
(\\0) str
(';) p n
() N
(         ) S
(/* Process the name=value pair */) c n
(         ) p
(if) K
( \(!strcasecmp\(name, ") p
(acct) str
("\)\) {) p n
(            acctmode = parseMode\(value, NONE\);) N
(            ) S
(if) K
( \(wait0 < 0\) ) p
(switch) K
( \(acctmode\) {) p n
(               ) S
(case) K
( POSTSCRIPT: wait0 = DEFLT_WAIT0_PS; ) p
(break) K
(;) p n
(               ) S
(case) K
( PJL: wait0 = DEFLT_WAIT0_PJL; ) p
(break) K
(;) p n
(               ) S
(default) K
(: wait0 = 0; ) p
(break) K
(;) p n
(            }) N
(            ) S
(if) K
( \(wait1 < 0\) ) p
(switch) K
( \(acctmode\) {) p n
(               ) S
(case) K
( POSTSCRIPT: wait1 = DEFLT_WAIT1_PS; ) p
(break) K
(;) p n
(               ) S
(case) K
( PJL: wait1 = DEFLT_WAIT1_PJL; ) p
(break) K
(;) p n
(               ) S
(default) K
(: wait1 = 0; ) p
(break) K
(;) p n
(            }) N
(         }) N
(         ) S
(else) K
( ) p
(if) K
( \(!strcasecmp\(name, ") p
(pagecost) str
("\)\) {) p n
(            pagecost = atoi\(value\);) N
(         }) N
(         ) S
(else) K
( ) p
(if) K
( \(!strcasecmp\(name, ") p
(wait0) str
("\)\) {) p n
(            ) S
(if) K
( \(scanu\(value, &number\)\)) p n
(               wait0 = \() S
(int) k
(\) number;) p n
(         }) N
(         ) S
(else) K
( ) p
(if) K
( \(!strcasecmp\(name, ") p
(wait1) str
("\)\) {) p n
(            ) S
(if) K
( \(scanu\(value, &number\)\)) p n
(               wait1 = \() S
(int) k
(\) number;) p n
(         }) N
(         ) S
(else) K
( ) p
(if) K
( \(!strcasecmp\(name, ") p
(jobscan) str
("\)\) {) p n
(            jobscan = value;) N
(         }) N
(      }) N
(   }) N
(}) N
() N
(/*) c n
( * Translate the string pointed to by value) N
( * to one of the accounting/synchronising modes.) N
( */) N
(mode parseMode\() p
(const) K
( ) p
(char) k
( *value, mode deflt\)) p n
({) N
(   ) S
(if) K
( \(strcasecmp\(value, ") p
(off) str
("\) == 0\) ) p
(return) K
( NONE;) p n
(   ) S
(if) K
( \(strcasecmp\(value, ") p
(PJL) str
("\) == 0\) ) p
(return) K
( PJL;) p n
(   ) S
(if) K
( \(strcasecmp\(value, ") p
(PS) str
("\) == 0\) ) p
(return) K
( POSTSCRIPT;) p n
(   ) S
(if) K
( \(strcasecmp\(value, ") p
(PostScript) str
("\) == 0\) ) p
(return) K
( POSTSCRIPT;) p n
(   ) S
(if) K
( \(strcasecmp\(value, ") p
(job) str
("\) == 0\) ) p
(return) K
( JOBSCAN;) p n
(   ) S
(return) K
( deflt;) p n
(}) N
() N
(/*) c n
( * Translate the string pointed to by value to either) N
( * true \(1\) or false \(0\), or return the given default.) N
( */) N
(int) k
( parseOnOff\() p
(const) K
( ) p
(char) k
( *value, ) p
(int) k
( deflt\)) p n
({) N
(   ) S
(if) K
( \(strcasecmp\(value, ") p
(on) str
("\) == 0\) ) p
(return) K
( 1;) p n
(   ) S
(if) K
( \(strcasecmp\(value, ") p
(off) str
("\) == 0\) ) p
(return) K
( 0;) p n
(   ) S
(if) K
( \(strcasecmp\(value, ") p
(yes) str
("\) == 0\) ) p
(return) K
( 1;) p n
(   ) S
(if) K
( \(strcasecmp\(value, ") p
(no) str
("\) == 0\) ) p
(return) K
( 0;) p n
(   ) S
(if) K
( \(strcasecmp\(value, ") p
(true) str
("\) == 0\) ) p
(return) K
( 1;) p n
(   ) S
(if) K
( \(strcasecmp\(value, ") p
(false) str
("\) == 0\) ) p
(return) K
( 0;) p n
(cupspracc.c) (Page 17/23) (Mar 15, 11 22:10) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   ) p
(return) K
( deflt;) p n
(}) N
() N
(int) k
( copyuser\() p
(char) k
( *dest, ) p
(int) k
( size, ) p
(const) K
( ) p
(char) k
( *s\)) p n
({) N
(   ) S
(int) k
( i = 0;) p n
() N
(   ) S
(while) K
( \(i < size-1\)) p n
(   {) N
(      ) S
(char) k
( c = s[i];) p n
(      ) S
(if) K
( \(!c\) ) p
(break) K
(;) p n
() N
(      dest[i] = tolower\(c\);) N
(      i += 1;) N
(   }) N
() N
(   dest[i] = 0; ) S
(// terminate string) c n
(}) p n
() N
(/*) c n
( * Copy the job title given in s into the buffer dest[size].) N
( * Chop an initial "smbprn.XXXXXXXX", replace white space) N
( * by underscores, and replace non-printable characters by) N
( * question marks.) N
( *) N
( * The resulting string in dest is always NUL-terminated.) N
( * Return the number of characters copied.) N
( */) N
(int) k
( copytitle\() p
(char) k
( *dest, ) p
(int) k
( size, ) p
(const) K
( ) p
(char) k
( *s\)) p n
({) N
(   ) S
(register) K
( ) p
(char) k
( *p = dest;) p n
(   ) S
(char) k
( *end = p + size - 1;) p n
() N
(   ) S
(if) K
( \(strncmp\(") p
(smbprn.) str
(", s, 7\) == 0\) {) p n
(      s += 7; ) S
(while) K
( \(*s\)) p n
(         ) S
(if) K
( \(!isdigit\(*s++\)\) ) p
(break) K
(;) p n
(   }) N
() N
(   ) S
(while) K
( \(p < end\) {) p n
(      ) S
(register) K
( ) p
(char) k
( c = *s++;) p n
(      ) S
(if) K
( \(isgraph\(c\)\) *p++ = c;) p n
(      ) S
(else) K
( ) p
(if) K
( \(isspace\(c\)\) *p++ = ') p
(_) str
(';) p n
(      ) S
(else) K
( ) p
(if) K
( \(c != ') p
(\\0) str
('\) *p++ = ') p
(?) str
(';) p n
(      ) S
(else) K
( ) p
(break) K
(; ) p
(// end of string) c n
(   }) p n
(   ) S
(if) K
( \(size > 0\) *p = ') p
(\\0) str
(';) p n
() N
(   ) S
(return) K
( p - dest; ) p
(// #chars) c n
(}) p n
() N
(/*) c n
( * Check if user 'username' is allowed to access account) N
( * 'acctname' and exit if not.) N
( *) N
( * If access is denied, try to record the error in the) N
( * requesting user's personal account \(this is useful) N
( * feedback on invalid job-billing values\), then quit) N
( * and cancel the job.) N
( */) N
(void) k
( checkaccess\() p
(const) K
( ) p
(char) k
( *username, ) p
(const) K
( ) p
(char) k
( *acctname\)) p n
({) N
(   ) S
(int) k
( result;) p n
(cupspracc.c) (Page 18/23) (Mar 15, 11 22:10) title
border
grestore
(Printed by Urs-Jakob) rhead
(cupspracc.c) (9/12) (Sunday April 10, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (19-20) 10
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(   assert\(username && acctname\);) N
() N
(   result = praccGrant\(username, acctname\);) N
(   ) S
(if) K
( \(result < 0\) ) p
(// system error - see errno) c n
(      die\(CUPS_BACKEND_FAILED, ") p
(praccGrant failed) str
("\);) p n
() N
(   ) S
(if) K
( \(result > 0\) { ) p
(// deny access to account) c n
(      ) p
(char) k
( s[MAXNAME+32];) p n
() N
(      strncpy\(s, acctname, MAXNAME\);) N
(      strcat\(s, ") S
(: Access denied) str
("\);) p n
(      praccAppend\(username, ') S
(!) str
(', -1, jobuser, s\);) p n
() N
(      die\(CUPS_BACKEND_CANCEL, ") S
(praccGrant\(%s to %s\) = DENY) str
(",) p n
(          username, acctname\);) N
(   }) N
() N
(   log_debug\(") S
(praccGrant\(%s to %s\) = GRANT) str
(", username, acctname\);) p n
(}) N
() N
(/*) c n
( * Write the given buffer to the given file descriptor) N
( * in blocking mode: do not return until all data has) N
( * been written or an error occurred.) N
( *) N
( * Use this function for sending small amounts of data) N
( * to the printer en block without bothering about the) N
( * printer's asynchronous replies. Careful: this could) N
( * create a dead-lock \(no select-loop\)!) N
( *) N
( * Return 0 if OK or -1/errno if an error occurred.) N
( */) N
(int) k
( writeall\() p
(int) k
( fd, ) p
(const) K
( ) p
(char) k
( *buf, ) p
(unsigned) k
( len\)) p n
({) N
(   ) S
(int) k
( ret;) p n
() N
(   ) S
(if) K
( \(fdblocking\(fd\) < 0\) ) p
(return) K
( -1; ) p
(// see errno) c n
() p n
(   ) S
(if) K
( \(writen\(fd, buf, len\) < 0\) ) p
(return) K
( -1; ) p
(// see errno) c n
() p n
(   ) S
(return) K
( 0; ) p
(// OK) c n
(}) p n
() N
(/*) c n
( * On some special devices \(notably terminals, networks, streams\)) N
( * a write\(\) operation may return less than specified. This isn't) N
( * an error and we should continue with the remainder of the data.) N
( * This phenomenon never happens with ordinary disk files.) N
( *) N
( * See Stevens \(1993, p.406-408\) for details.) N
( */) N
(ssize_t writen\() p
(int) k
( fd, ) p
(const) K
( ) p
(void) k
( *buf, size_t len\)) p n
({) N
(   size_t nbytes = len;) N
(   ) S
(char) k
( * bufptr = \() p
(char) k
( *\) buf;  ) p
(// no ptr arith with void star) c n
() p n
(   ) S
(while) K
( \(nbytes > 0\) {) p n
(      ssize_t n = write\(fd, bufptr, nbytes\);) N
(      ) S
(if) K
( \(n <= 0\) ) p
(return) K
( -1; ) p
(// see errno) c n
(      nbytes -= n;) p n
(      bufptr += n;) N
(cupspracc.c) (Page 19/23) (Mar 15, 11 22:10) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   }) p n
() N
(   ) S
(return) K
( len;) p n
(}) N
() N
(/*) c n
( * These two functions take a descriptor of an open file \(or pipe,) N
( * socket, etc\) and set/clear the O_NONBLOCK bit in the status flags) N
( * Return -1 on error, some other value if ok.) N
( */) N
() p n
(#ifndef) K
( O_NONBLOCK) p n
(#error) K
( Your system headers ) p
(do) K
( not define O_NONBLOCK.) p n
(#endif) K n
() p n
(int) k
( fdblocking\() p
(int) k
( fd\)) p n
({) N
(   ) S
(return) K
( fcntl\(fd, F_SETFL, fcntl\(fd, F_GETFL, 0\) & ~O_NONBLOCK\);) p n
(}) N
() N
(int) k
( fdnonblock\() p
(int) k
( fd\)) p n
({) N
(   ) S
(return) K
( fcntl\(fd, F_SETFL, fcntl\(fd, F_GETFL, 0\) | O_NONBLOCK\);) p n
(}) N
() N
(/*) c n
( * Try getting the job-billing IPP/CUPS job attribute.) N
( * Return an malloc'ed string of NULL on failure.) N
( *) N
( * The Get-Job-Attributes operation request attributes:) N
( *  attributes-charset) N
( *  attributes-natural-language) N
( *  printer-uri AND job-id OR job-uri) N
( *) N
( * This function makes use of CUPS API routines.) N
( */) N
(char) k
( *cupsGetJobBilling\() p
(const) K
( ) p
(char) k
( *printer, ) p
(long) k
( jobid\)) p n
({) N
(   http_t *http;          ) S
(// HTTP connection object) c n
(   ipp_t *request;        ) p
(// IPP request object) c n
(   ipp_t *response;       ) p
(// IPP response object) c n
(   ipp_attribute_t *attr; ) p
(// current IPP attr in response) c n
(   ) p
(const) K
( ) p
(char) k
( *) p
(const) K
( attrs[] = { ") p
(job-billing) str
(" };) p n
(   ) S
(int) k
( numattrs = 1; ) p
(// sizeof\(attrs\) / sizeof\(attrs[0]\)) c n
(   ) p
(char) k
( uri[HTTP_MAX_URI];) p n
(   ) S
(char) k
( *jobBillingString;) p n
() N
(   http = httpConnectEncrypt\(cupsServer\(\), ippPort\(\), cupsEncryption\(\)\);) N
(   ) S
(if) K
( \(!http\) ) p
(return) K
( \() p
(char) k
( *\) 0;) p n
() N
(   request = ippNewRequest\(IPP_GET_JOB_ATTRIBUTES\);) N
(   ) S
(if) K
( \(!request\) ) p
(return) K
( \() p
(char) k
( *\) 0;) p n
() N
(   snprintf\(uri, ) S
(sizeof) K
( uri, ") p
(ipp://%s/printers/%s/) str
(",) p n
(      cupsServer\(\), printer\);) N
(   ippAddString\(request, IPP_TAG_OPERATION, IPP_TAG_URI,) N
(      ") S
(printer-uri) str
(", ) p
(NULL) K
(, uri\);) p n
() N
(   ippAddInteger\(request, IPP_TAG_OPERATION, IPP_TAG_INTEGER,) N
(      ") S
(job-id) str
(", jobid\);) p n
() N
(   numattrs = ) S
(sizeof) K
(\(attrs\) / ) p
(sizeof) K
(\(attrs[0]\);) p n
(cupspracc.c) (Page 20/23) (Mar 15, 11 22:10) title
border
grestore
(Printed by Urs-Jakob) rhead
(cupspracc.c) (10/12) (Sunday April 10, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (21-22) 11
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   ippAddStrings\(request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD,) p n
(      ") S
(requested-attributes) str
(", numattrs, ) p
(NULL) K
(, attrs\);) p n
() N
(   jobBillingString = \() S
(char) k
( *\) 0; ) p
(// assume failure) c n
(   response = cupsDoRequest\(http, request, ") p
(/) str
("\); ) p
(// XXX /jobs ?) c n
(   ) p
(if) K
( \(response && response->request.status.status_code == IPP_OK\)) p n
(      ) S
(for) K
( \(attr = response->attrs; attr; attr = attr-> next\)) p n
(         ) S
(if) K
( \(strcmp\(attr->name, ") p
(job-billing) str
("\) == 0\)) p n
(            jobBillingString = strdup\(attr->values[0].string.text\);) N
() N
(   ippDelete\(response\); ) S
(// request is deleted by cupsDoRequest\(\)) c n
(   httpClose\(http\);) p n
() N
(   ) S
(return) K
( jobBillingString;) p n
(}) N
() N
(static) K
( ) p
(void) k
( private_log\() p
(const) K
( ) p
(char) k
( *fmt, ...\)) p n
({) N
(   ) S
(static) K
( ) p
(FILE) k
( *logfp = 0;) p n
(   ) S
(static) K
( ) p
(int) k
( first = 1;) p n
(   va_list ap;) N
() N
(   ) S
(if) K
( \(first\) {) p n
(      ) S
(int) k
( logfd;) p n
(      ) S
(struct) k
( stat stbuf;) p n
() N
(      first = 0;) N
() N
(      ) S
(/* Can't use fopen\(\) because it creates the file! */) c n
(      logfd = open\(PRIVATE_LOGFILE, O_APPEND | O_WRONLY\);) p n
(      ) S
(if) K
( \(logfd < 0\) ) p
(return) K
(; ) p
(// silently give up) c n
(      logfp = fdopen\(logfd, ") p
(a) str
("\);) p n
(      ) S
(if) K
( \(!logfp\) ) p
(return) K
(; ) p
(// silently give up) c n
() p n
(      ) S
(/* Truncate to zero if too long */) c n
(      ) p
(if) K
( \(fstat\(fileno\(logfp\), &stbuf\) == 0\)) p n
(         ) S
(if) K
( \(stbuf.st_size > 1000000\)) p n
(            ftruncate\(fileno\(logfp\), 0\);) N
(   }) N
() N
(   ) S
(if) K
( \(logfp\) {) p n
(      va_start\(ap, fmt\);) N
(      fprintf\(logfp, ") S
(Job %ld: ) str
(", jobid\); ) p
(// tag) c n
(      vfprintf\(logfp, fmt, ap\);) p n
(      fflush\(logfp\);) N
(      va_end\(ap\);) N
(   }) N
(}) N
() N
(/*) c n
( * Notify the CUPS log file about normal things going on.) N
( * Use warn\(\) for warnings and die\(\) for fatal errors.) N
( *) N
( * Note: The scheduler \(at least in version 1.2.2\) seems) N
( *       to NOT log INFO strings from backends. Annoying.) N
( */) N
(void) k
( log_info\() p
(const) K
( ) p
(char) k
( *fmt, ...\)) p n
({) N
(   ) S
(char) k
( msg[256];) p n
() N
(   va_list ap;) N
(   va_start\(ap, fmt\);) N
(cupspracc.c) (Page 21/23) (Mar 15, 11 22:10) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(   vsnprintf\(msg, ) S
(sizeof) K
( msg, fmt, ap\);) p n
(   fprintf\(stderr, ") S
(INFO: %s\\n) str
(", msg\);) p n
(   private_log\(") S
(INFO: %s\\n) str
(", msg\);) p n
() N
(   va_end\(ap\);) N
(}) N
() N
(/*) c n
( * Issue a PAGE message to standard error. There are two types) N
( * of PAGE messages used by CUPS:) N
( *) N
( * PAGE: n m         # add m to job-media-sheets-completed attr) N
( * PAGE: n total     # set job-media-sheets-completed attr to n) N
( *) N
( * If copies is negative, then the second version is produced,) N
( * if both arguments are positive, the first version is written.) N
( */) N
(void) k
( log_page\() p
(long) k
( number, ) p
(long) k
( copies\)) p n
({) N
(   assert\(number >= 0\);) N
() N
(   ) S
(if) K
( \(copies < 0\) fprintf\(stderr, ") p
(PAGE: %ld total\\n) str
(", number\);) p n
(   ) S
(else) K
( fprintf\(stderr, ") p
(PAGE: %ld %ld\\n) str
(", number, copies\);) p n
(}) N
() N
(/*) c n
( * Issue a state change message to standard error:) N
( *) N
( * STATE: +printer-state-reason      # add) N
( * STATE: -printer-state-reason      # remove) N
( * STATE: printer-state-reason       # set) N
( *) N
( * The CUPS scheduler will parse these messages and add/remove/set) N
( * printer-state-reason keywords to the print queue. Typical use is) N
( * to report media and ink/toner conditions. Backends may also use) N
( * it to report "connecting-to-device" to the scheduler.) N
( */) N
(void) k
( log_state\() p
(const) K
( ) p
(char) k
( *s\)) p n
({) N
(   fprintf\(stderr, ") S
(STATE: %s\\n) str
(", s\);) p n
(}) N
() N
(/*) c n
( * Issue a debug message to standard error) N
( * Because CUPS seems to loose messages,) N
( * we also log to our private debug log!) N
( */) N
(void) k
( log_debug\() p
(const) K
( ) p
(char) k
( *fmt, ...\)) p n
({) N
(   ) S
(char) k
( msg[256];) p n
() N
(   va_list ap;) N
(   va_start\(ap, fmt\);) N
() N
(   vsnprintf\(msg, ) S
(sizeof) K
( msg, fmt, ap\);) p n
(   fprintf\(stderr, ") S
(DEBUG: %s\\n) str
(", msg\);) p n
(   private_log\(") S
(DEBUG: %s\\n) str
(", msg\);) p n
() N
(   va_end\(ap\);) N
(}) N
() N
(cupspracc.c) (Page 22/23) (Mar 15, 11 22:10) title
border
grestore
(Printed by Urs-Jakob) rhead
(cupspracc.c) (11/12) (Sunday April 10, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (23) 12
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/*) c n
( * Issue an error message to standard error.) N
( * Append strerror\(errn\) if errno is non-zero.) N
( */) N
(void) k
( log_error\() p
(const) K
( ) p
(char) k
( *fmt, ...\)) p n
({) N
(   ) S
(char) k
( msg[256];) p n
() N
(   va_list ap;) N
(   va_start\(ap, fmt\);) N
() N
(   vsnprintf\(msg, ) S
(sizeof) K
( msg, fmt, ap\);) p n
(   ) S
(if) K
( \(errno == 0\) fprintf\(stderr, ") p
(ERROR: %s\\n) str
(", msg\);) p n
(   ) S
(else) K
( fprintf\(stderr, ") p
(ERROR: %s: %s\\n) str
(", msg, strerror\(errno\)\);) p n
(   ) S
(if) K
( \(errno == 0\) private_log\(") p
(ERROR: %s\\n) str
(", msg\);) p n
(   ) S
(else) K
( private_log\(") p
(ERROR: %s: %s\\n) str
(", msg, strerror\(errno\)\);) p n
() N
(   va_end\(ap\);) N
(}) N
() N
(/*) c n
( * Issue an error message to standard error.) N
( * Append strerror\(errno\) if errno is non-zero.) N
( * Exit with given code \(see CUPS_BACKEND_XXX constants\).) N
( */) N
(void) k
( die\() p
(int) k
( code, ) p
(const) K
( ) p
(char) k
( *fmt, ...\)) p n
({) N
(   ) S
(char) k
( msg[256];) p n
(   ) S
(int) k
( saverr = errno;) p n
() N
(   va_list ap;) N
(   va_start\(ap, fmt\);) N
() N
(   vsnprintf\(msg, ) S
(sizeof) K
(\(msg\), fmt, ap\);) p n
() N
(   ) S
(if) K
( \(saverr == 0\) fprintf\(stderr, ") p
(ERROR: %s\\n) str
(", msg\);) p n
(   ) S
(else) K
( fprintf\(stderr, ") p
(ERROR: %s: %s\\n) str
(", msg, strerror\(errno\)\);) p n
(   ) S
(if) K
( \(saverr == 0\) private_log\(") p
(ERROR: %s\\n) str
(", msg\);) p n
(   ) S
(else) K
( private_log\(") p
(ERROR: %s: %s\\n) str
(", msg, strerror\(errno\)\);) p n
() N
(   va_end\(ap\);) N
() N
(   exit\(code\);) N
(}) N
() N
(void) k
( cancel\() p
(int) k
( signo\)) p n
({) N
(   errno = 0; ) S
(// prevent strerror\(errno\) in message!) c n
(   log_error\(") p
(Killed by signal %d) str
(", signo\);) p n
(   log_info\(") S
(Job cancelled, printer ready) str
("\);) p n
(   exit\(CUPS_BACKEND_CANCEL\);) N
(}) N
(cupspracc.c) (Page 23/23) (Mar 15, 11 22:10) title
border
grestore
(Printed by Urs-Jakob) rhead
(cupspracc.c) (12/12) (Sunday April 10, 2011) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
