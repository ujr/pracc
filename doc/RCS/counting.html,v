head	1.1;
access;
symbols;
locks
	ujr:1.1; strict;
comment	@# @;


1.1
date	2008.01.17.16.28.09;	author ujr;	state Exp;
branches;
next	;


desc
@About counting pages for accounting purposes
@


1.1
log
@Initial revision
@
text
@<html>
<head>
<title>Pracc: Page Counting</title>
<style type="text/css">
 body { margin:2pc }
 pre { margin:10px; padding:5px;
       border:1px solid black; background-color:#ccc }
 h1,h2,h3 { font-family:sans-serif }
 th { font-family:sans-serif; text-align:left }
 td.code { background-color:#ccc }
</style>
</head>
<body>

<p><i>Written by Urs-Jakob R&uuml;etschi<br/>
as part of the <b>pracc</b> project.</i></p>

<h1>Page Counting</h1>

<p>Sending a print job to a networked printer is easy,
but counting how many pages get printed is delicate.</p>

<p>One approach is to run the job through a software printer, such
as GhostScript. Besides using many CPU cycles and opening potential
security holes, it also tends to count too many pages: whenever the
printer is out of paper, there is a paper jam, or a similar problem,
fewer pages get printed than there are in the print job. Users tend
to be sensitive in that respect...</p>

<p>Another approach is to use the page counter hardware register
that is found in most printers: read it before and after each job;
the difference is the number of pages printed. This is fine in theory,
but in praxis there is a problem: We do not know when the printer is
done printing a job. This may be well after the last byte of the job
has been sent to the printer and the connection is closed. The page
counter was introduced as a help for printer maintenance, not for
accounting purposes. A simple heuristics is to read the page counter
once every few seconds until it remains constant.</p>

<p>HP's Printer Job Language (PJL) offers some help to solve this
problem: it can send an &quot;unsolicited status&quot; message when
a job starts printing and when it ends printing; the end-of-job
message also includes the number of pages printed. Therefore, PJL
should be used for accounting whenever possible. And it should be
remembered that counting printed pages (as opposed to job pages)
is never 100% accurate.</p>

<a name="ps"></a>
<h2>Page Counting with PostScript</h2>

<p>The printer's pagecount hardware register can be read
through PostScript. It is convenient to wrap the pagecount
into a PostScript message so that it can be parsed along
with other PostScript messages.</p>

<p>To avoid confusion with pagecount messages from previous
print jobs or even to guard against maliciously generated
messages, a random &quot;cookie&quot; value should be included
in the pagecount message. The returned cookie can be used to
determine if the pagecount message is genuine.</p>

<pre>%!PS
(%%[ pagecount: ) print
statusdict begin pagecount end
20 string cvs print
(; cookie: 99999 ]%%) print flush</pre>

<p>The pagecount value is put on the stack, converted
to a string representation, and finally printed to the
printer's standard output, formatted as a PostScript
message that also contains the cookie value:</p>

<pre>%%[ pagecount: 12345; cookie: 99999 ]%%</pre>

<p>The <b>pscount</b>(<i>fd</i>, <i>cookie</i>) routine
can be used to send the above PostScript program, containing
the given <i>cookie</i>, to the given file descriptor <i>fd</i>.
On receipt of a syntactically correct pagecount message, the
PostScript message parser, <b>psparse</b>, sets  the global
variables <i>ps_pagecount</i> and <i>ps_cookie</i>. The caller
of <b>psparse</b> should then check if <i>ps_cookie</i> is
identical to the cookie that was passwd to <b>pscount</b>
and, if so, use <i>ps_pagecount</i> to update the program's
record of the initial or the final pagecount.</p>

<p>Unfortunately, there is no known way to determine the end
of a print job using PostScript. The best we can do is read
the pagecount repeatedly until it remains stable for some time.
Of course, this is only a heuristic and easily be fooled, for
example by carefully preparing a print job that includes a
delay loop...</p>

<a name="pjl"></a>
<h2>Page Counting with PJL</h2>

<p>HP's Printer Job Language (PJL) has features that specifically
support page-based accounting: By requesting &quot;unsolicited
status&quot; messages, the printer informs the host about pages
printed and print job start and end. Besides, it is also possible
to query the printer's pagecount register using PJL.</p>

<p>My <a href="lowlevel.html">low-level PJL code</a> includes routines
for generating the required PJL statements and parsing the PJL response
messages. The architecture of a print job for page counting should be:</p>

<table border="1" cellpadding="2">
<tbody>
<tr><th>Print Job</th><th>Comments</th></tr>
<tr><td class="code"><tt>UEL@@PJL</tt></td>
    <td><b>pjluel</b>(<i>fd</i>)</td></tr>
<tr><td class="code"><tt>@@PJL ECHO <i>cookie</i></tt></td>
    <td><b>pjlecho</b>(<i>fd</i>, <i>cookie</i>)</td></tr>
<tr><td class="code"><tt>@@PJL INFO PAGECOUNT</tt></td>
    <td><b>pjlcount</b>(<i>fd</i>)<br><i>optional</i></td>
<tr><td class="code"><tt>@@PJL USTATUS JOB = ON<br>
@@PJL JOB NAME = "<i>jobid</i>"<br>
UEL</tt> or <tt>ENTER LANGUAGE</tt></td>
    <td><b>pjljob</b>(<i>fd</i>, <i>jobid</i>, 0 or "PCL" or "POSTSCRIPT")</td></tr>
<tr><td class="code"><tt>%!PS<br>showpage</tt></td>
    <td>Send print job data.<br>
        Use a select loop and process messages<br>
        that may be sent back from the printer</td></tr>
<tr><td class="code"><tt>UEL@@PJL</tt></td>
    <td><b>pjleoj</b>(<i>fd</i>, <i>jobid</i>)</td></tr>
<tr><td colspan="2">Wait for &quot;unsolicited&quot; PAGE and JOB messages<br>
        using a select loop and process incoming messages.</td></tr>
<tr><td class="code"><tt>UEL@@PJL USTATUSOFF<br>UEL</tt></td>
    <td><b>pjloff</b>(<i>fd</i>)<br>
        <b>pjluel</b>(<i>fd</i>)<br>
        This is important to avoid USTATUS messages<br>
        now that we are no longer interested.</td></tr>
</tbody>
</table>

<p>The code that reacts on the messages received back from the printer
has to be careful not to interpret messages from previous print jobs.
That's the purpose of the PJL ECHO statement in the print job. This is
easiest handled in four sequential phases:</p>

<blockquote>INIT &gt;&gt; SYNCED &gt;&gt; INJOB &gt;&gt; DONE</blockquote>

<p>The transition from INIT ty SYNCED is triggered by the arrival
of our @@PJL ECHO <i>cookie</i> message; the transition from SYNCED
to INJOB is by the @@PJL USTATUS JOB START message; the transition
from INJOB to DONE by the @@PJL USTATUS JOB END message.
Unexpected ECHO or USTATUS JOB messages should be ignored.</p>

<p>@@PJL USTATUS PAGE messages should be processed in the phase
INJOB by updating the <i>pages</i> variable and issuing a
&quot;PAGE: <i>n</i> 1&quot; log line for the CUPS scheduler
to update the job-media-sheets-completed attribute.</p>

<p>A @@PJL INFO PAGECOUNT message in phase SYNCED should be used
to set the <i>pagecount</i> variable. In other phases, such
messages should be ignored.</p>

<p>A @@PJL USTATUS JOB END message in phase INJOB should be used
to set the <i>pages</i> variable that is to be used for accounting.
After receipt of the JOB END message, be sure to issue a USTATUSOFF
statement to turn &quot;unsolicited status&quot; messages off.</p>

<div><hr>
Copyright (c) 2003-2007 by Urs-Jakob R&uuml;etschi</div>

</body>
</html>
@
