head	1.3;
access;
symbols;
locks
	ujr:1.3; strict;
comment	@# @;


1.3
date	2011.04.10.13.51.49;	author ujr;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.17.16.28.02;	author ujr;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.04.12.19.42;	author ujr;	state Exp;
branches;
next	;


desc
@Description of PostScript and PJL low-level routines.
@


1.3
log
@*** empty log message ***
@
text
@<html>
<head>
<title>Pracc: Low-Level PostScript and PJL Routines</title>
<style type="text/css">
 body { margin:2pc }
 pre { margin:10px; padding:5px;
       border:1px solid black; background-color:#ccc }
 h1,h2,h3 { font-family: sans-serif }
</style>
</head>
<body>

<p><i>Written by Urs-Jakob R&uuml;etschi<br/>
as part of the <b>pracc</b> project.</i></p>

<h1>Low-Level PostScript and PJL Routines</h1>

<p>Low-level <a href="#output">output</a> and
<a href="#parser">parsing</a> routines for PostScript and PJL.<br/>
PostScript-specific code is in the <i>ps.h</i> and <i>ps.c</i>
source files.<br/>
PJL-specific code is in the <i>pjl.h</i> and <i>pjl.c</i>
source files.</p>

<a name="output"></a>
<h3>Output Routines</h3>
<p>All these routines return <b>0</b> if successful
and <b>-1</b>/errno on failure.</p>

<pre>
void <b>psinit</b>(void);
void <b>pjlinit</b>(void);
</pre>

<p>Initialize global variables in the PS / PJL module
and reset the message parser.</p>

<pre>
int <b>psecho</b>(int <i>fd</i>, int <i>cookie</i>);
int <b>pjlecho</b>(int <i>fd</i>, int <i>cookie</i>);
</pre>

<p>Send a PS print / PJL ECHO statement that prints/echoes the given
cookie. Use a random number as the cookie value. The parser stores
the cookie, once received back from the printer, in a global variable.
Use this routine to synchronise with the printer, so that we
do not parse the previous job's page counts...</p>

<pre>
int <b>pscount</b>(int <i>fd</i>, int <i>cookie</i>);
int <b>pjlcount</b>(int <i>fd</i>);
</pre>

<p>Send a small PS program / PJL INFO PAGECOUNT statement. The parser
stores the pagecount, once received back from the printer, in a
global variable. For PostScript, a cookie is included in the
generated program which can be used to determine if the message
received was the one generated by <b>pscount</b>.</p>

<pre>
int <b>pjluel</b>(int <i>fd</i>);
int <b>pjljob</b>(int <i>fd</i>, int <i>jobid</i>, char *<i>personality</i>, char *<i>display</i>);
int <b>pjleoj</b>(int <i>fd</i>, int <i>jobid</i>);
int <b>pjloff</b>(int <i>fd</i>);
</pre>

<p>The <b>pjluel</b> routine sends <tt><i>UEL</i>@@PJL\r\n</tt> to the given
file descriptor, where <tt><i>UEL</i></tt> is the Universal Escape Language
sequence <tt>\033%-12345X</tt>. This is useful to get the PJL interpreter's
attention. Use it according to HP's PJL specification.</p>

<p>The <b>pjljob</b> and <b>pjleoj</b> routines should be used
to frame a print job. They issue the PJL JOB and PJL EOJ commands.
Their <i>job</i> argument is the job's &quot;name&quot; (max 80 chars
per PJL specification; for simplicity we use the decimal representation
of an integer). If personality is null, we hope that the printer
auto-detects the print job language, otherwise, pjljob emits an
ENTER LANGUAGE statement. The <i>display</i> argument is the string
to show on the printer's display while printing the job; if NULL,
it defaults to "Job ID printing", where ID is the <i>job</i> argument.
Per PJL specification, calls to these routines must be properly nested!</p>

<p>The <b>pjloff</b> routine sends a PJL statement to turn off
&quot;unsolicited status&quot; messages. Such messages were
requested by <b>pjljob</b> to get messages from the printer
about job start and end and even individual pages printed.
Note that these status messages cannot be turned off in <b>pjleoj</b>,
because at the time <b>pjleoj</b> is invoked we are still interested
in getting status messages.</p>

<a name="parser"></a>
<h3>Message Parser</h3>
<p>There are two parsers, <b><i>xxx</i>parse</b>() to parse a PostScript
or PJL message, and <b><i>xxx</i>char</b>() to find a PostScript or PJL
message in a continuous stream of bytes. The latter calls the former
if a message is found.</p>

<pre>
int <b>pschar</b>(char <i>c</i>);
int <b>pjlchar</b>(char <i>c</i>);
</pre>

<p>These routines should be called repeatedly with bytes read from
the printer. They look through the buffer provided for a PostScript
or a PJL message and call the respective <b><i>xxx</i>parse</b>()
routines if one is found. Messages can span across buffer boundaries
but must not exceed MBSIZE bytes (an internal constant) in length or
they will not be recognised as messages.</p>

<pre>
int <b>psparse</b>(const char *<i>buf</i>, unsigned <i>len</i>);
int <b>pjlparse</b>(const char *<i>buf</i>, unsigned <i>len</i>);
</pre>

<p>These routines parse PostScript / PJL messages and set global
variables (<tt>ps_<i>xxx</i></tt> / <tt>pjl_<i>xxx</i></tt>)
according to the parsed messages. The return value is an indication
of the type of message that was parsed and should be used by
the calling function to determine what variables to read and
what actions to take (e.g., change state in a FSM).</p>

<table border="1" cellpadding="2" align="center">
<tbody>
<tr><th colspan=2>Messages generated by</th><th rowspan=2>Message<br>value</th></tr>
<tr><th>PJL</th><th>PS</th></tr>
<tr><td><tt>PJL_MSG_COOKIE</tt></td><td><tt>PS_MSG_COOKIE</tt></td>
 <td align="center">1</td></tr>
<tr><td><tt>PJL_MSG_PAGECOUNT</tt></td><td><tt>PS_MSG_PAGECOUNT</tt></td>
 <td align="center">2</td></tr>
<tr><td><tt>PJL_MSG_JOBSTART</tt></td><td></td>
 <td align="center">3</td></tr>
<tr><td><tt>PJL_MSG_JOBEND</tt></td><td></td>
 <td align="center">4</td></tr>
<tr><td><tt>PJL_MSG_PAGE</tt></td><td></td>
 <td align="center">5</td></tr>
<tr><td></td><td><tt>PS_MSG_PRERROR</tt></td>
 <td align="center">6</td></tr>
<tr><td></td><td><tt>PS_MSG_FLUSHING</tt></td>
 <td align="center">7</td></tr>
<tr><td><tt>PJL_MSG_OTHER</tt></td><td><tt>PS_MSG_OTHER</tt></td>
 <td align="center">88</td></tr>
<tr><td></td><td><tt>PS_MSG_MALFORMED</tt></td>
 <td align="center">99</td></tr>
</tbody>
</table> 

<div><hr>
Copyright (c) 2005-2007 by Urs-Jakob R&uuml;etschi</div>

</body>
</html>
@


1.2
log
@*** empty log message ***
@
text
@d62 2
a63 2
int <b>pjljob</b>(int <i>fd</i>, int <i>job</i>, char *<i>personality</i>);
int <b>pjleoj</b>(int <i>fd</i>, int <i>job</i>);
d78 4
a81 2
ENTER LANGUAGE statement. Per PJL specification, calls to these
routines must be properly nested!</p>
d126 18
a143 9
<tr><td>PJL_MSG_COOKIE</td><td>PS_MSG_COOKIE</td><td align="center">1</td></tr>
<tr><td>PJL_MSG_PAGECOUNT</td><td>PS_MSG_PAGECOUNT</td><td align="center">2</td></tr>
<tr><td>PJL_MSG_JOBSTART</td><td></td><td align="center">3</td></tr>
<tr><td>PJL_MSG_JOBEND</td><td></td><td align="center">4</td></tr>
<tr><td>PJL_MSG_PAGE</td><td></td><td align="center">5</td></tr>
<tr><td></td><td>PS_MSG_PRERROR</td><td align="center">6</td></tr>
<tr><td></td><td>PS_MSG_FLUSHING</td><td align="center">7</td></tr>
<tr><td>PJL_MSG_OTHER</td><td>PS_MSG_OTHER</td><td align="center">88</td></tr>
<tr><td></td><td>PS_MSG_MALFORMED</td><td align="center">99</td></tr>
@


1.1
log
@Initial revision
@
text
@d5 4
a8 4
 body { margin: 2pc }
 pre { margin: 10px; padding: 5px;
       border: 1px solid black; background-color: #ccc }
 h1, h2, h3 { font-family: sans-serif }
d13 3
a16 2
<p>by Urs-Jakob R&uuml;etschi<br/>
   part of the <b>pracc</b> project</p>
d136 3
@
