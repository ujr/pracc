head	1.2;
access;
symbols;
locks
	ujr:1.2; strict;
comment	@ * @;


1.2
date	2006.10.14.11.59.39;	author ujr;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.14.07.35.01;	author ujr;	state Exp;
branches;
next	;


desc
@The pracc API call for reading an account,
i.e., getting its current balance and limit.
@


1.2
log
@Use the new praccpath() to obtain the absolute path
to a pracc file; no longer chdir(2) to the PRACCDIR.
@
text
@#include "pracc.h"
#include "skipline.h"
#include <errno.h>
#include <unistd.h>

/* return 0 if ok, 1 if no pracc file, -1 on error */

int readacct(const char *account, long *bp, long *lp)
{
  int oldfd;
  unsigned n;
  int c, partial;
  char line[MAXLINE], *p;
  long lineno, value;
  long balance, limit;

  if ((oldfd = dup(0)) < 0) return -1; // errno
  if ((p = praccpath(account)) == 0) return -1; // ENOMEM
  if (setin(p) < 0) {
  	(void) close(oldfd);
  	if (errno == ENOENT) return 1; /* no acct */
  	return -1; /* other file open error */
  }

  lineno = 0;
  balance = limit = 0;
  while (getline(p=line, sizeof(line), '\n', &partial) > 0) {
  	lineno += 1;
  	switch (c = *p++) {
  		case '-': /* debit line */
  			n = scanu(p, &value);
  			if (n > 0) balance -= value;
  			break;
  		case '+': /* credit line */
  			n = scanu(p, &value);
  			if (n > 0) balance += value;
  			break;
  		case '=': /* reset line */
  			n = scani(p, &value);
  			if (n > 0) balance = value;
  			break;
  		case '$': /* limit line */
  			n = scani(p, &value);
  			if (n > 0) limit = value;
  			else limit = UNLIMITED;
  			break;
  		default: /* skip */
  			break;
  	}
endline:
  	if (partial) skipline('\n');
  }

  if (dup2(oldfd, 0) < 0) return -1;

  if (bp) *bp = balance;
  if (lp) *lp = limit;

  return 0; /* ok */
}
@


1.1
log
@Initial revision
@
text
@d13 1
a13 1
  char buf[MAXLINE], *p;
d17 3
a19 3
  if (chdir(PRACCDIR) < 0) return -1;
  if ((oldfd = dup(0)) < 0) return -1;
  if (setin(account) < 0) {
d27 1
a27 1
  while (getline(p=buf, sizeof(buf), '\n', &partial) > 0) {
@
