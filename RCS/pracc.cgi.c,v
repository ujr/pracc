head	1.4;
access;
symbols;
locks
	ujr:1.4; strict;
comment	@ * @;


1.4
date	2008.04.14.19.17.15;	author ujr;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.04.16.40.33;	author ujr;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.04.10.45.21;	author ujr;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.03.22.14.17;	author ujr;	state Exp;
branches;
next	;


desc
@Pracc web interface
@


1.4
log
@*** empty log message ***
@
text
@/* Pracc Web GUI, $Revision: 1.3 $ */
/* Copyright (c) 2008 by Urs Jakob Ruetschi */

#include "backdate.h"
#include "cgi.h"
#include "common.h"
#include "pracc.h"
#include "symtab.h"

#include "acct.h"
#include "accts.h"
#include "pclog.h"
#include "pracclog.h"
#include "report.h"

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <grp.h>
#include <pwd.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

#define streq(s,t) (strcmp((s),(t)) == 0)

#define TITLE "Printer Accounting" /* override in templates */

void authorise(const char *user, const char *path);

int doUser(const char *suffix);
int doAdmin(const char *suffix);
int doAccounts(const char *suffix);
int doReports(const char *suffix);
int doLogs(const char *suffix);
int doVars(const char *suffix);

int doCreateAccount(void);
int doEditAccount(void);
int doPurgeAccount(void);
int doDeleteAccount(void);

int doCredits(void);
int doAccountViewer(const char *acctname);
int doCreateChecks(void);

void install(const char *name, const char *value);
char *lookup(const char *name, const char *deflt);

void arrayInit(const char *name);
int arrayLoad(const char *name, int index);

char getacctinfo(const char *acctname, long *balance, long *limit);
void sendfile(const char *vn);
int parsedate(const char *s, time_t *tp);
int parseamount(const char *s, long *value);
int parsetype(const char *s, char *type);
void instdate(struct tm *tmp);
void instint(const char *name, long value);
void setdate(const char *name, time_t t);

static void printsym(struct symbol *sym)
{ if (sym && sym->sval) printf(" %s=%s$\n", sym->name, sym->sval); }
static void dumpsym(struct symbol *sym)
{ if (sym && sym->sval) fprintf(stderr, " %s=%s$\n", sym->name, sym->sval); }

struct symtab syms; // global symbol store
const char *myname; // basename of this program

int main(int argc, char **argv)
{
   const char *user;
   const char *path;
   const char *s;

   /* Initialise */

   myname = progname(argv);
   if (!myname) return 127;

   syminit(&syms, 128);
   cgiInit();

   user = lookup("REMOTE_USER", 0);
   path = lookup("PATH_INFO", "/");
   authorise(user, path);

   /* Branch depending on section */

   if (s = cgiPathPrefix(path, "/user"))
      return doUser(s);

   if (s = cgiPathPrefix(path, "/admin"))
      return doAdmin(s);

   if (s = cgiPathPrefix(path, "/accounts"))
      return doAccounts(s);

   if (s = cgiPathPrefix(path, "/reports"))
      return doReports(s);

   if (s = cgiPathPrefix(path, "/logs"))
      return doLogs(s);

   if (s = cgiPathPrefix(path, "/vars"))
      return doVars(s);

   if (streq(path, "/")) {
      install("SECTION", "main");
      cgiStartHTML(TITLE);
      cgiCopyTemplate("main.tmpl", 0);
      cgiEndHTML();
   }
   else sendfile(path);

   return 0; // OK
}

/*
 * Authorisation: check if the given user is allowed
 * on the given path; return if so, exit if not.
 *
 * This function assumes that user was authenticated.
 */
void authorise(const char *user, const char *path)
{
   const char *group;
   struct group *gr;
   char **pp;

   /* Style file and images are always allowed */

   if (streq(path, "/style.css")) return;
   if (cgiPathPrefix(path, "/images")) return;

   /* Require authentication */

   if (!user) {
      cgiStartHTML(TITLE);
      cgiError("You are not authenticated, sorry!");
      cgiEndHTML();
      exit(0);
   }

   /*
    * Authorisation:
    * everybody is allowd to pracc.cgi/user
    */

   if (cgiPathPrefix(path, "/user")) return;

   /*
    * Authorisation:
    * group PRACCPOKE required for pracc.cgi/admin
    * group PRACCPEEK required for everything else
    */

   if (cgiPathPrefix(path, "/admin")) {
      gr = getgrnam(group = PRACCPOKE);
      if (gr) for (pp = gr->gr_mem; *pp; pp++)
         if (streq(*pp, user)) return; // OK
   }
   else { // any other path requires PRACCPEEK
      gr = getgrnam(group = PRACCPEEK);
      if (gr) for (pp = gr->gr_mem; *pp; pp++)
         if (streq(*pp, user)) return; // OK
      gr = getgrnam(group = PRACCPOKE);
      if (gr) for (pp = gr->gr_mem; *pp; pp++)
         if (streq(*pp, user)) return; // OK
   }

   /* Not authorised: complain */

   cgiStartHTML(TITLE);
   if (gr) cgiCopyTemplate("accessdenied.tmpl", 0);
   else cgiError("Function getgrnam(%s) failed.", group);
   cgiEndHTML();

   exit(0);
}

/*
 * Handle pracc.cgi/user and user.tmpl;
 *
 * EVERYBODY is authorised to go to this page, so we must make
 * sure they watch only their own account(s) using praccGrant().
 * (Not yet implemented because only personal account, not group
 * accounts, can be viewed at this time.)
 */
int doUser(const char *suffix)
{
   const char *acctname;
   time_t tmin, tmax;
   char *period, *types;
   char class;

   install("SECTION", "user");

   assert(acctname = lookup("REMOTE_USER", 0));
   class = getacctinfo(acctname, 0, 0);

   if ((period = lookup("period", 0)) == 0)
       install("period", period = "month");

   daterange(period, &tmin, &tmax);
   setdate("tmin", tmin);
   setdate("tmax", tmax);

   if (lookup("types", 0) == 0)
      install("types", ""); // all types
   
   cgiStartHTML(TITLE);
   if (class) cgiCopyTemplate("user.tmpl", 0);
   else cgiError("No accounting for %s?", acctname);
   cgiEndHTML();

   return 0; // OK
}

/*
 * Handle pracc.cgi/admin and admin.tmpl
 *
 * All functions that change anything to the pracc system are
 * grouped here so that it is easy to require special rights.
 *
 *   op=create/edit/purge/delete/credits/checks
 *
 * If there is no valid op specified, show the admin.tmpl page.
 */
int doAdmin(const char *suffix)
{
   const char *op = lookup("op", "");

   install("SECTION", "admin");

   if (streq(op, "create"))
      return doCreateAccount();

   if (streq(op, "credits"))
      return doCredits();

   if (streq(op, "edit"))
      return doEditAccount();

   if (streq(op, "purge"))
      return doPurgeAccount();

   if (streq(op, "delete"))
      return doDeleteAccount();

   if (streq(op, "checks"))
      return doCreateChecks();

   cgiStartHTML(TITLE);
   cgiCopyTemplate("admin.tmpl", 0);
   cgiEndHTML();

   return 0; // OK
}

int doAccounts(const char *suffix)
{
   install("SECTION", "accounts");

   /* Account specified? */
   if (suffix && (suffix[0] == '/') && suffix[1]) {
      const char *acctname = &suffix[1];

      if (getacctinfo(acctname, 0, 0))
            doAccountViewer(acctname);
      else {
         cgiStartHTML(TITLE); errno = 0;
         cgiError("%s: No such account", acctname);
         cgiEndHTML();
      }
      return 0; // OK
   }

   /* List all accounts */
   if (streq(lookup("format", ""), "csv")) {
      printf("Content-type: text/csv\r\n"); // HTTP header, see also RFC 2183
      printf("Content-disposition: attachment; filename=Accounts.csv\r\n\r\n");
      if (accts_dump(stdout, lookup("filter", 0)) < 0)
         printf("ERROR: %s\n", strerror(errno));
   }
   else {
      cgiStartHTML(TITLE);
      cgiCopyTemplate("accounts.tmpl", 0);
      cgiEndHTML();
   }

   return 0; // OK
}

int doReports(const char *suffix)
{
   time_t tmin, tmax;
   const char *period;

   install("SECTION", "reports");

   /* Handle time period stuff */

   period = lookup("period", "");
   if (streq(period, "")) {
      if (parsedate(lookup("tmin", ""), &tmin)); else tmin = -1;
      if (parsedate(lookup("tmax", ""), &tmax)); else tmax = -1;
      if (tmax >= 0) tmax += 86399; // 23:59:59
   }
   else daterange(period, &tmin, &tmax);

   if ((tmin < 0) || (tmax < 0))
      daterange("month", &tmin, &tmax);

   setdate("tmin", tmin);
   setdate("tmax", tmax);

   /* Download CSV... */
   if (streq(lookup("format", ""), "csv")) {
      printf("Content-type: text/csv\r\n"); // HTTP header, see also RFC 2183
      printf("Content-disposition: attachment; filename=PraccReport.csv\r\n\r\n");
      if (report_dump(stdout, tmin, tmax, lookup("acctlist", 0)) < 0)
         printf("ERROR: %s\n", strerror(errno));
   }
   /* ...or show template with {report#...} defined */
   else {
      cgiStartHTML(TITLE);
      cgiCopyTemplate("reports.tmpl", 0);
      cgiEndHTML();
   }

   return 0; // OK
}

int doLogs(const char *suffix)
{ 
   install("SECTION", "logs");

   if (streq(suffix, "/pracc.log"))
      cgiCopyVerbatim(PRACCLOG, "text/plain");
   else if (streq(suffix, "/pc.log"))
      cgiCopyVerbatim(PRACCPCLOG, "text/plain");
   else if (streq(suffix, "/pracc")) {
      if (streq(lookup("format", ""), "csv")) {
         time_t tmin, tmax;
         char *filter, *types;

         if (parsedate(lookup("tmin", ""), &tmin)); else tmin = -1;
         if (parsedate(lookup("tmax", ""), &tmax)); else tmax = -1;
         if (tmax >= 0) tmax += 86399; // 23:59:59

         filter = lookup("filter", 0);
         types = lookup("types", 0);

         /* Print HTTP header and data */
         printf("Content-type: text/csv\r\n"); // see also RFC 2183
         printf("Content-disposition: attachment; filename=Log.csv\r\n\r\n");
         if (pracclog_dump(stdout, tmin, tmax, filter, types))
            printf("ERROR: %s\n", strerror(errno));
      }
      else {
         cgiStartHTML(TITLE);
         cgiCopyTemplate("pracclog.tmpl", 0);
         cgiEndHTML();
      }
   }
   else if (streq(suffix, "/pclog")) {
      if (streq(lookup("format", ""), "csv")) {
         time_t tmin, tmax;

         if (parsedate(lookup("tmin", ""), &tmin)); else tmin = -1;
         if (parsedate(lookup("tmax", ""), &tmax)); else tmax = -1;
         if (tmax >= 0) tmax += 86399; // 23:59:59

         /* Print HTTP header and data */
         printf("Content-type: text/csv\r\n"); // see also RFC 2183
         printf("Content-disposition: attachment; filename=pclog.csv\r\n\r\n");
         if (pclog_dump(stdout, tmin, tmax, lookup("filter", 0)) < 0)
            printf("ERROR: %s\n", strerror(errno));
      }
      else {
         cgiStartHTML(TITLE);
         cgiCopyTemplate("pclog.tmpl", 0);
         cgiEndHTML();
      }
   }
   else { // default
      cgiStartHTML(TITLE);
      cgiCopyTemplate("logs.tmpl", 0);
      cgiEndHTML();
   }
   return 0; // OK
}

int doVars(const char *suffix)
{
   install("SECTION", "vars");

   cgiStartHTML(TITLE);
   cgiCopyTemplate("vars.tmpl", 0);
   cgiEndHTML();
}

int doCreateAccount(void)
{
   char *value, *limit, *acct;
   long thevalue, thelimit;
   int badacct, badvalue, badlimit;
   char *who, *comment;

   acct = lookup("acct", 0);
   badacct = acct && (praccCheckName(acct) != 0);
   install("badacct", (badacct) ? "" : 0);

   value = lookup("value", 0);
   badvalue = value && !parseamount(value, &thevalue);
   install("badvalue", (badvalue) ? "" : 0);

   limit = lookup("limit", 0);
   if (limit && streq(limit, "none")) {
      thelimit = UNLIMITED;
      badlimit = 0;
   }
   else badlimit = limit && !parseamount(limit, &thelimit);
   install("badlimit", (badlimit) ? "" : 0);

   if (acct && !badacct && value && !badvalue && limit && !badlimit) {
      mode_t oldmask = umask(0117);

      comment = lookup("comment", 0);
      who = lookup("REMOTE_USER", lookup("USER", "?"));
      if (praccCreate(acct, thevalue, thelimit, who, comment, 0) == 0) {
         char buf[MAXLINE], s[16];

         /* Add log record */
         if (thelimit == UNLIMITED) strcpy(s, "none");
         else snprintf(s, sizeof(s), "%ld", thelimit);
         snprintf(buf, sizeof(buf), "init %ld limit %s", thevalue, s);
         (void) praccLogup(who, acct, buf);

         install("status", "ok");
      }
      else {
         install("status", "fail");
         install("error", strerror(errno));
      }
      umask(oldmask);

      /* Reset fields */
      install("value", 0);
      install("limit", 0);
      install("comment", 0);
   }
   else install("status", 0);

   cgiStartHTML(TITLE);
   cgiCopyTemplate("create.tmpl", 0);
   cgiEndHTML();
   
   return 0; // OK
}

int doEditAccount(void)
{
   char *acct, *type, *value, *comment;
   int badacct, badtype, badvalue, badcomment;
   char thetype = 0;
   long thevalue;
   int valid, confirmed;

   acct = lookup("acct", 0);
   badacct = acct && !getacctinfo(acct, 0, 0);
   install("badacct", (badacct) ? "" : 0);

   type = lookup("type", 0);
   badtype = type && !parsetype(type, &thetype);
   install("badtype", (badtype) ? "" : 0);

   value = lookup("value", 0);
   if (value && strchr("+-=$", thetype)) {
      if ((thetype == '$') && streq(value, "none")) {
         thevalue = UNLIMITED;
         badvalue = 0;
      }
      else if (parseamount(value, &thevalue)) {
         if ((thevalue < 0) && ((thetype == '+') || (thetype == '-')))
            badvalue = 1;
         else badvalue = 0;
      }
      else badvalue = 1;
   }
   else badvalue = 0; // no value or type in {error,note}
   install("badvalue", (badvalue) ? "" : 0);

   comment = lookup("comment", 0); // mandatory for note and error
   badcomment = !((thetype != '#' && thetype != '!') || (comment && *comment));
   install("badcomment", (badcomment) ? "" : 0);

   valid = acct && !badacct && type && !badtype && !badvalue && !badcomment;
   confirmed = streq(lookup("confirm", ""), "yes");
   install("confirm", (valid && !confirmed) ? "" : 0);

   if (valid && confirmed) {
      char *who = lookup("REMOTE_USER", lookup("USER", "?"));

      if (praccAppend(acct/*name*/, thetype, thevalue, who, comment) == 0) {
         char buf[MAXLINE], s[16];
         char *ts = praccTypeString(thetype);

         /* Add log record */
         if ((thetype == '+') || (thetype == '-') || (thetype == '='))
            snprintf(buf, sizeof(buf), "%s %ld", ts, thevalue);
         else if (thetype == '$') {
            if (thevalue == UNLIMITED) strcpy(s, "none");
            else snprintf(s, sizeof(s), "%ld", thevalue);
            snprintf(buf, sizeof(buf), "%s %s", ts, s);
         }
         else snprintf(buf, sizeof(buf), "%s added", ts);
         (void) praccLogup(who, acct/*name*/, buf);

         install("status", "ok");
      }
      else {
         install("status", "fail");
         install("error", (errno) ? strerror(errno) : "error");
      }
   }
   else install("status", 0);

   cgiStartHTML(TITLE);
   cgiCopyTemplate("acctedit.tmpl", 0);
   cgiEndHTML();

   return 0; // OK
}

int doPurgeAccount(void)
{
   cgiStartHTML(TITLE);
   errno = 0;
   cgiError("Sorry, the purge function is not yet implemented.");
   cgiEndHTML();

   return 0; // OK
}

int doDeleteAccount(void)
{
   char *acctname;
   char *who, *comment;
   long balance, limit;

   acctname = lookup("acct", "");
   if (*acctname && streq(lookup("confirm", ""), "yes")) {
      comment = lookup("comment", 0);
      who = lookup("REMOTE_USER", lookup("USER", "?"));

      if ((praccSum(acctname, &balance, &limit, 0, 0, 0) == 0)
          && (praccDelete(acctname) == 0)) {
         char buf[MAXLINE], s[16];

         /* Add log record */
         if (limit == UNLIMITED) strcpy(s, "none");
         else snprintf(s, sizeof(s), "%ld", limit);
         snprintf(buf, sizeof(buf), "delete balance=%ld limit=%s %s",
                    balance, s, comment ? comment : "");
         (void) praccLogup(who, acctname, buf);

         install("status", "ok");
      }
      else {
         install("status", "fail");
         install("error", (errno) ? strerror(errno) : "error");
      }
   }
   else install("status", 0);

   cgiStartHTML(TITLE);
   cgiCopyTemplate("acctkill.tmpl", 0);
   cgiEndHTML();

   return 0; // OK
}

/* Gutschriften */
int doCredits(void)
{
   char *acct, *value;
   char class;
   long thevalue;
   int badacct, badvalue;
   int valid, confirmed;

   acct = lookup("acct", 0);
   class = getacctinfo(acct, 0, 0);
   badacct = acct && (class == 0);
   install("badacct", (badacct) ? "" : 0);

   value = lookup("value", 0);
   badvalue = value && (!parseamount(value, &thevalue) || (thevalue < 0));
   install("badvalue", (badvalue) ? "" : 0);

   valid = acct && !badacct && value && !badvalue;
   confirmed = streq(lookup("confirm", ""), "yes");
   install("confirm", (valid && !confirmed) ? "" : 0);

   if (valid && confirmed) {
      long balance;
      char *who = lookup("REMOTE_USER", lookup("USER", "?"));
      char *comment = lookup("comment", 0);

      if (praccAppend(acct, '+', thevalue, who, comment) == 0) {
         char buf[MAXLINE];

         /* Get new balance */
         getacctinfo(acct, 0, 0);

         /* Add log record */
         snprintf(buf, sizeof(buf), "credit %ld", thevalue);
         (void) praccLogup(who, acct, buf);

         install("status", "ok");
      }
      else {
         install("status", "fail");
         install("error", (errno) ? strerror(errno) : "error");
      }

      /* Reset fields */
      install("value", 0);
      install("comment", 0);
      install("confirm", 0);
      install("gecos", 0);
   }
   else install("status", 0);

   cgiStartHTML(TITLE);
   cgiCopyTemplate("credits.tmpl", 0);
   cgiEndHTML();

   return 0; // OK
}

int doAccountViewer(const char *acctname)
{
   time_t tmin, tmax;
   const char *period;

   assert(acctname);

   period = lookup("period", "");
   if (streq(period, "")) {
      if (parsedate(lookup("tmin", ""), &tmin)); else tmin = -1;
      if (parsedate(lookup("tmax", ""), &tmax)); else tmax = -1;
      if (tmax >= 0) tmax += 86399; // 23:59:59
   }
   else daterange(period, &tmin, &tmax);

   if ((tmin < 0) || (tmax < 0))
      daterange("month", &tmin, &tmax);

   setdate("tmin", tmin);
   setdate("tmax", tmax);

   (void) getacctinfo(acctname, 0, 0);

   cgiStartHTML(TITLE);
   cgiCopyTemplate("acctview.tmpl", 0);
   cgiEndHTML();

   return 0; // OK
}

int doCreateChecks(void)
{
   cgiStartHTML(TITLE);
   errno = 0;
   cgiError("Sorry, checks are not yet implemented.");
   cgiEndHTML();

   return 0; // OK
}

/*
 * Install a name=value pair in the global symbol store.
 * ALL symbol definitions MUST GO THROUGH THIS FUNCTION.
 *
 * Beware of the case sym->sval == value, which happens
 * if we do sth like
 *   install("name", value);
 *   install("name", lookup("name", ...));
 * In this case, free() would invalidate value and the
 * following strdup() would be meaningless!
 */
void install(const char *name, const char *value)
{
   struct symbol *sym;

   sym = symput(&syms, name);
   if (sym) {
      if (sym->sval != value) {
         if (sym->sval) free((void *) sym->sval);
         if (value) value = strdup(value);
         sym->sval = value;
      }
      else /* see notes above */ ;
   }
   else cgiError("Symbol install failed");
}

char *lookup(const char *name, const char *deflt)
{
   struct symbol *sym;

   if (!name) return (char *) deflt;

   sym = symget(&syms, name);
   if (sym) return (sym->sval) ? (char *) sym->sval : (char *) deflt;

   if (streq(name, "symtab")) symdump(&syms, stdout);
   if (streq(name, "symdump")) symeach(&syms, printsym);

   return (char *) deflt;
}

/*
 * Prepare the named array for subsequent calls to arrayLoad.
 * Know arrays are:
 *  accts -- list of all accounts
 *  pclog -- entries in the pc.log pagecount log
 *  pracclog -- entries in the pracc.log
 *  acct -- entries in a single account
 */
void arrayInit(const char *name)
{
   char buf[128];
   const char *s;
   int r, n = -1;

   if (streq(name, "accts")) {
      const char *filter;

      /* Implicit asterisk on non-empty filter */
      filter = lookup("filter", 0);
      if (filter && filter[0] &&
          (!strchr(filter, '*') || !strchr(filter, '?'))) {
         snprintf(buf, sizeof(buf), "%s*", filter);
         filter = buf;
      }

      if ((r = accts_init(filter)) < 0)
         install("error", strerror(errno));
      else n = accts_count();
   }
   else if (streq(name, "pclog")) {
      time_t tmin, tmax;
      const char *filter;

      if (parsedate(lookup("tmin", 0), &tmin)); else tmin = -1;
      if (parsedate(lookup("tmax", 0), &tmax)); else tmax = -1;
      if (tmax >= 0) tmax += 86399; // 23:59:59

      filter = lookup("filter", "");
      if (!filter[0]) filter = 0;
    
      r = pclog_init(tmin, tmax, filter);
      if (r < 0) install("error", strerror(errno));
      else {
         instint("pclog.totpages", pcpages);
         instint("pclog.totcount", pccount);
         n = pclog_count();
      }
   }
   else if (streq(name, "pracclog")) {
      time_t tmin, tmax;
      const char *filter;
      const char *types; // i d c r l n p x

      if (parsedate(lookup("tmin", 0), &tmin)); else tmin = -1;
      if (parsedate(lookup("tmax", 0), &tmax)); else tmax = -1;
      if (tmax >= 0) tmax += 86399; // 23:59:59

      filter = lookup("filter", 0);
      types = lookup("types", 0);

      if ((r = pracclog_init(tmin, tmax, filter, types)) < 0)
         install("error", strerror(errno));
      else n = pclog_count();
   }
   else if (streq(name, "acct")) {
      const char *acct;
      time_t tmin, tmax;
      const char *period;
      const char *types;

      acct = lookup("acct", 0);

      period = lookup("period", "");
      if (streq(period, "")) { // custom?
         if (parsedate(lookup("tmin", ""), &tmin)); else tmin = -1;
         if (parsedate(lookup("tmax", ""), &tmax)); else tmax = -1;
         if (tmax >= 0) tmax += 86399; // 23:59:59
      }
      else daterange(period, &tmin, &tmax);

      if ((tmin < 0) || (tmax < 0))
         daterange("month", &tmin, &tmax);

      setdate("tmin", tmin);
      setdate("tmax", tmax);

      types = lookup("types", 0);

      if ((r = acct_init(acct, tmin, tmax, types)) < 0)
         install("error", strerror(errno));
      else n = acct_count();
   }
   else if (streq(name, "report")) {
      const char *acctlist;
      const char *period;
      time_t tmin, tmax;

      period = lookup("period", "");
      if (streq(period, "")) { // custom?
         if (parsedate(lookup("tmin", ""), &tmin)); else tmin = -1;
         if (parsedate(lookup("tmax", ""), &tmax)); else tmax = -1;
         if (tmax >= 0) tmax += 86399; // 23:59:59
      }
      else daterange(period, &tmin, &tmax);

      if ((tmin < 0) || (tmax < 0))
         daterange("lastyear", &tmin, &tmax);

      setdate("tmin", tmin);
      setdate("tmax", tmax);

      acctlist = lookup("acctlist", 0);

      if ((r = report_init(tmin, tmax, acctlist)) == 0) {
         long credits, debits;
         report_totals(&credits, &debits);
         instint("report.totcredits", credits);
         instint("report.totdebits", debits);
         n = report_count();
      }
      else install("error", strerror(errno));
   }

   if (n >= 0) { // num-of-records
      instint("nr", (long) n);
   }
}

/*
 * Load the given index of the named array
 * into the global symbol table.
 *
 * Return 0 if ok, 1 if no such index,
 * and -1 on any other error (with errno set).
 */
int arrayLoad(const char *name, int index)
{
   char buf[32];
   int r;

   if (streq(name, "accts")) {
      char *acct;

      r = accts_get(index-1, &acct);
      if (r == 0) getacctinfo(acct, 0, 0);
   }
   else if (streq(name, "pclog")) {
      char *name;
      time_t t;
      long pc, pages, jobs;

      r = pclog_get(index-1, &name, &t, &pc, &pages, &jobs);
      if (r == 0) {
         install("printer", name);
         instint("pc", pc);
         instint("pages", pages);
         instint("jobs", jobs);

         instdate(localtime(&t));
      }
   }
   else if (streq(name, "pracclog")) {
      time_t t;
      char *user, *acct, *info;

      r = pracclog_get(0, &t, &user, &acct, &info);
      if (r == 0) {
         instdate(localtime(&t));
         install("user", user);
         install("acct", acct);
         install("info", info);
         // type = i d c r l n p x   TODO
      }
      else if (r < 0)
         install("error", strerror(errno));
      else {
         long n = pracclog_count();
         instint("nr", n);
      }
   }
   else if (streq(name, "acct")) {
      time_t t;
      char type, *user, *comment;
      long value;

      r = acct_get(0, &t, &type, &value, &user, &comment);
      if (r == 0) {
         sprintf(buf, "%c", type);
         install("type", buf);
         if ((type == '$') && (value == UNLIMITED))
            snprintf(buf, sizeof(buf), "%s", "none");
         else if ((type == '#') || (type == '!'))
            buf[0] = '\0'; // no value for note/error
         else sprintf(buf, "%ld", value);
         install("value", buf);
         instdate(localtime(&t));
         install("user", user);
         install("comment", comment);
      }
      else if (r < 0)
         install("error", strerror(errno));
      else {
         long n = acct_count();
         instint("nr", n);
      }
   }
   else if (streq(name, "report")) {
      struct acctinfo *aip;
      char class;

      r = report_get(index-1, &aip);
      if (r == 0) {
         class = praccAccountInfo(aip->acct, buf, sizeof(buf));
         if (class) {
            install("acct", aip->acct);
            install("gecos", (buf[0]) ? buf : 0);
            sprintf(buf, "%c", class);
            install("class", buf);
            instint("balance", aip->balance);
            if (aip->limit == UNLIMITED) {
               install("limit", "none");
               install("diff", "999999999");
            }
            else {
               instint("limit", aip->limit);
               instint("diff", aip->balance - aip->limit);
            }
            instint("credits", aip->credits);
            instint("debits", aip->debits);
            instdate(localtime(&aip->lastused));
         }
         else r = -1;
      }
      else if (r < 0)
         install("error", strerror(errno));
      else {
         // install totals
      }
   }
   else r = 1;

   return r;
}

void sendfile(const char *vn)
{
   char path[1024];
   char *type = cgiGuessMimeType(vn);
   char *prefix = cgiDocumentBase();
   struct stat stbuf;

   assert(vn);

   if (vn[0] == '/') ++vn;
   snprintf(path, sizeof(path), "%s/%s", prefix, vn);
   if (stat(path, &stbuf) == 0) {
      if (S_ISDIR(stbuf.st_mode)) errno = EISDIR;
      else { // try sending the file
         cgiCopyVerbatim(path, type);
         return;
      }
   }
   cgiStartHTML(TITLE);
   cgiError("Requested operation cannot be performed");
   cgiEndHTML();
}

/*
 * Add account information to the global symbol store:
 *  acct, class, gecos, balance, limit;
 *  year, month, day, time (of last use);
 *  diff (=balance-limit, 999999999 if unlimited).
 * If bp is not NULL, store the account's balance there.
 * If lp is not NULL, store the account's limit there.
 *
 * Return the account class, 0 if no such account.
 */
char getacctinfo(const char *acctname, long *bp, long *lp)
{
   long balance, limit;
   time_t lastused;
   char buf[128], class;

   if (!acctname) return 0;

   class = praccAccountInfo(acctname, buf, sizeof(buf));
   if (!class) return class; // no such account or error

   install("acct", acctname);
   install("gecos", (buf[0]) ? buf : 0);
   sprintf(buf, "%c", class);
   install("class", buf);

   if (praccSum(acctname, &balance, &limit, 0, 0, &lastused))
      install("error", strerror(errno));
   else {
      struct tm *tmp;
      snprintf(buf, sizeof(buf), "%ld", balance);
      install("balance", buf);
      if (limit == UNLIMITED) {
         install("limit", "none");
         install("diff", "999999999");
      }
      else {
         instint("limit", limit);
//         snprintf(buf, sizeof(buf), "%ld", limit);
//         install("limit", buf);
         instint("diff", balance - limit);
//         snprintf(buf, sizeof(buf), "%ld", balance-limit);
//         install("diff", buf);
      }
      instdate(localtime(&lastused));

      if (bp) *bp = balance;
      if (lp) *lp = limit;
   }
   return class;
}

/*
 * Install year, month, day, time in the global
 * symbol table, based on the given struct tm.
 * Month and day with a leading zero of < 10.
 * Time in "military" HHMM format.
 */
void instdate(struct tm *tmp)
{
   char buf[32];

   if (tmp) {
      sprintf(buf, "%d", 1900+tmp->tm_year);
      install("year", buf);
      sprintf(buf, "%02d", 1+tmp->tm_mon);
      install("month", buf);
      sprintf(buf, "%02d", tmp->tm_mday);
      install("day", buf);
      sprintf(buf, "%04d", 100*tmp->tm_hour + tmp->tm_min);
      install("time", buf);
   }
   else {
      install("year", 0);
      install("month", 0);
      install("day", 0);
      install("time", 0);
   }
}

/*
 * Install name=value where value is a long integer
 * that will be rendered as a decimal integer.
 */
void instint(const char *name, long value)
{
   char buf[16];

   assert(name);

   snprintf(buf, sizeof(buf), "%ld", value);
   install(name, buf);
}

/*
 * Parse date in yyyy-mm-dd format into a TAI struct.
 * Return number of characters scanned or 0 on error.
 */
int parsedate(const char *s, time_t *tp)
{
   struct tm tm;
   time_t t;
   int n;

   if (!s) return 0;
   if (!(n = scandate(s, &tm))) return 0;

   tm.tm_sec = tm.tm_min = tm.tm_hour = 0;
   if ((t = mktime(&tm)) < 0) return 0;

   if (tp) *tp = t;

   return n; // #chars scanned
}

/*
 * Parse an amount, which is required to be one of these forms:
 * N or N.M where N is any integer (also negative) and M is one
 * or two decimal digits. Store 100*N+M in the value pointer.
 * Return the number of characters parsed or 0 on error.
 */
int parseamount(const char *s, long *value)
{
   const char *p = s;
   long N = 0, M = 0;
   int n, sign = 1;

   if (*p == '-') { sign = -1; ++p; }
   else if (*p == '+') ++p; // skip

   if (n = scanu(p, &N)) p += n;
   else return 0;

   if (*p == '.') {
      if ((n = scanu(++p, &M)) && (n < 3)) p += n;
      else return 0;
   }

   if (*p) return 0;
  
   if (value) *value = sign * (100*N + M);

   return p - s; // #chars parsed
}

/*
 * Parse the given string for an account record type.
 * Return the number of characters parsed or 0 on error.
 */
int parsetype(const char *s, char *type)
{
   if (!s || !*s) return 0;

   if (streq(s, "credit")) {
      if (type) *type = '+';
      return 6;
   }
   if (streq(s, "debit")) {
      if (type) *type = '-';
      return 5;
   }
   if (streq(s, "reset")) {
      if (type) *type = '=';
      return 5;
   }
   if (streq(s, "limit")) {
      if (type) *type = '$';
      return 5;
   }
   if (streq(s, "error")) {
      if (type) *type = '!';
      return 5;
   }
   if (streq(s, "note")) {
      if (type) *type = '#';
      return 4;
   }
   return 0;
}

void setdate(const char *name, time_t t)
{
   char buf[32];
   struct tm *tmp;

   assert(name);

   if (!(tmp = localtime(&t))) strcpy(buf, "?");
   else strftime(buf, sizeof(buf), "%Y-%m-%d", tmp);
   install(name, buf);
}
@


1.3
log
@All done except: pager, reports, debugging...
@
text
@d1 1
a1 1
/* Pracc Web GUI, $Revision: 1.2 $ */
d14 1
d63 1
d113 1
d131 1
d149 4
a152 1
   /* Access to user pages always granted */
d156 19
a174 5
   /* Check authorisation */

   gr = getgrnam(PRACCADMIN);
   if (gr) for (pp = gr->gr_mem; *pp; pp++)
      if (streq(*pp, user)) return; // OK
d179 2
a180 2
   if (gr) cgiError("You are not authorised, sorry!");
   else cgiError("Function getgrnam(%s) failed.", PRACCADMIN);
d182 1
d199 1
d204 1
a204 1
   (void) getacctinfo(acctname, 0, 0);
d209 1
a209 1
   tmin = backdate(0, period);
a210 2

   tmax = time(0); // now
d217 2
a218 1
   cgiCopyTemplate("user.tmpl", 0);
d301 3
d306 29
a334 3
   cgiStartHTML(TITLE);
   cgiCopyTemplate("reports.tmpl", 0);
   cgiEndHTML();
d356 2
a357 5
         filter = lookup("filter", "");
         if (!filter[0]) filter = 0;

         types = lookup("types", "");
         if (!types[0]) types = 0;
a373 1
         char *filter;
a378 3
         filter = lookup("filter", "");
         if (!filter[0]) filter = 0;

d382 1
a382 1
         if (pclog_dump(stdout, tmin, tmax, filter) < 0)
d440 1
a440 1
         if (thelimit <= UNLIMITED) strcpy(s, "none");
d518 1
a518 1
            if (thevalue <= UNLIMITED) strcpy(s, "none");
d562 1
a562 1
      if ((praccSum(acctname, 0, 0, &balance, &limit, 0, 0, 0) == 0)
d567 1
a567 1
         if (limit <= UNLIMITED) strcpy(s, "none");
d661 1
a661 4
   else {
      tmin = backdate(0, period);
      tmax = time(0); // now
   }
d663 2
a664 6
   if (tmin < 0) { // default: this month
      install("period", "month");
      tmin = backdate(0, "month");
   }
   if (tmax < 0) // default: now
      tmax = time(0);
d747 4
a750 2
      filter = lookup("filter", "");
      if (filter[0] && (!strchr(filter, '*') || !strchr(filter, '?'))) {
d773 2
a774 4
         sprintf(buf, "%ld", pcpages);
         install("pclog.totpages", buf);
         sprintf(buf, "%ld", pccount);
         install("pclog.totcount", buf);
d803 1
a803 1
      if (streq(period, "")) {
d808 4
a811 4
      else {
         tmin = backdate(0, period);
         tmax = time(0); // now
      }
d813 2
a814 6
      if (tmin < 0) { // default: this month
         install("period", "month");
         tmin = backdate(0, "month");
      }
      if (tmax < 0) // default: now
         tmax = time(0);
d822 30
d854 1
a854 2
      sprintf(buf, "%ld", (long) n);
      install("nr", buf);
d871 1
a871 20
      char class, *name, *gecos;
      long balance, limit;
      time_t t;
      int overdrawn;

      r = accts_get(index-1, &class, &name, &gecos, &balance, &limit, &t);
      if (r == 0) {
         sprintf(buf, "%c", class);
         install("class", buf);
         install("acct", name);
         install("gecos", (gecos && gecos[0]) ? gecos : 0);
         sprintf(buf, "%ld", balance);
         install("balance", buf);
         if (limit <= UNLIMITED)
            install("limit", "none");
         else {
            sprintf(buf, "%ld", limit);
            install("limit", buf);
         }
         instdate(localtime(&t));
d873 2
a874 3
         overdrawn = (balance <= limit) && (limit > UNLIMITED);
         install("overdrawn", overdrawn ? "" : 0);
      }
d884 3
a886 6
         sprintf(buf, "%ld", pc);
         install("pc", buf);
         sprintf(buf, "%ld", pages);
         install("pages", buf);
         sprintf(buf, "%ld", jobs);
         install("jobs", buf);
d907 1
a907 2
         sprintf(buf, "%ld", n);
         install("nr", buf);
d919 1
a919 1
         if ((type == '$') && (value <= UNLIMITED))
d933 34
a966 2
         sprintf(buf, "%ld", n);
         install("nr", buf);
d1010 1
a1010 1
   struct tai lastused;
d1023 1
a1023 1
   if (praccSum(acctname, 0, 0, &balance, &limit, 0, 0, &lastused))
d1026 1
a1026 2
      time_t t;
      struct tm tm;
d1029 3
a1031 5
      if (limit > UNLIMITED) {
         snprintf(buf, sizeof(buf), "%ld", limit);
         install("limit", buf);
         snprintf(buf, sizeof(buf), "%ld", balance-limit);
         install("diff", buf);
d1034 6
a1039 2
         install("limit", "none");
         install("diff", "999999999");
d1041 1
a1041 2
      t = tailocal(&lastused, &tm);
      instdate(localtime(&t));
d1078 14
@


1.2
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* Pracc Web GUI, $Revision: 1.1 $ */
d35 1
a36 2
int doCredits(const char *suffix);
int doChecks(const char *suffix);
a38 1
int doCreate(const char *suffix);
d41 8
a48 4
int doViewAccount(const char *acctname);
int doEditAccount(const char *acctname);
int doDeleteAccount(const char *acctname);
int doPurgeAccount(const char *acctname);
a62 1
//time_t backdate(time_t *tp, const char *period);
d95 3
a100 6
   if (s = cgiPathPrefix(path, "/credits"))
      return doCredits(s);

   if (s = cgiPathPrefix(path, "/checks"))
      return doChecks(s);

a106 3
   if (s = cgiPathPrefix(path, "/create"))
      return doCreate(s);

a124 1
 * At present, all paths are treated equal.
d170 1
a170 1
 * accounts, can be viewed at present.)
d176 3
a178 1
   char *period;
d182 1
d191 3
d195 40
a234 1
   install("SECTION", "user");
d237 1
a237 1
   cgiCopyTemplate("user.tmpl", 0);
a249 1
      char class = getacctinfo(acctname, 0, 0);
d251 2
a252 10
      if (class) {
         char *op = lookup("op", "");
         if (streq(op, "edit"))
            doEditAccount(acctname);
         else if (streq(op, "purge"))
            doPurgeAccount(acctname);
         else if (streq(op, "delete"))
            doDeleteAccount(acctname);
         else doViewAccount(acctname);
      }
d277 1
a277 1
int doViewAccount(const char *acctname)
d279 28
a306 3
   time_t tmin, tmax;
   const char *period;
   char class;
d308 2
a309 1
   assert(acctname);
d311 11
a321 5
   period = lookup("period", "");
   if (streq(period, "")) {
      if (parsedate(lookup("tmin", ""), &tmin)); else tmin = -1;
      if (parsedate(lookup("tmax", ""), &tmax)); else tmax = -1;
      if (tmax >= 0) tmax += 86399; // 23:59:59
d323 23
a345 3
   else {
      tmin = backdate(0, period);
      tmax = time(0); // now
d347 4
a350 4

   if (tmin < 0) { // default: this month
      install("period", "month");
      tmin = backdate(0, "month");
d352 2
a353 2
   if (tmax < 0) // default: now
      tmax = time(0);
d355 3
a357 4
   setdate("tmin", tmin);
   setdate("tmax", tmax);

   (void) getacctinfo(acctname, 0, 0);
d360 1
a360 1
   cgiCopyTemplate("acctview.tmpl", 0);
a361 2

   return 0; // OK
d364 1
a364 1
int doPurgeAccount(const char *acctname)
d366 49
a414 1
   assert(acctname);
d417 1
a417 2
   errno = 0;
   cgiError("Sorry, the purge function is not yet implemented.");
d419 1
a419 1

d423 1
a423 1
int doEditAccount(const char *acctname)
d425 2
a426 1
   char *type, *value, *comment;
a428 1
   int badtype, badvalue, badcomment;
d431 3
a433 3
   assert(acctname);

   install("SECTION", "accounts");
d459 1
a459 1
   valid = type && !badtype && !badvalue && !badcomment;
d466 1
a466 1
      if (praccAppend(acctname, thetype, thevalue, who, comment) == 0) {
d479 1
a479 1
         (void) praccLogup(who, acctname, buf);
d497 11
a507 1
int doDeleteAccount(const char *acctname)
d509 1
d513 2
a514 3
   assert(acctname);

   if (lookup("confirm", 0)) {
d546 1
a546 1
int doCredits(const char *suffix)
a553 2
   install("SECTION", "credits");

d604 1
a604 1
int doChecks(const char *suffix)
d606 2
a607 1
   install("SECTION", "checks");
d609 1
a609 2
   cgiStartHTML(TITLE);
   cgiEndHTML();
d611 5
a615 48
   return 0; // OK
}

int doReports(const char *suffix)
{
   install("SECTION", "reports");

   cgiStartHTML(TITLE);
   cgiCopyTemplate("reports.tmpl", 0);
   cgiEndHTML();

   return 0; // OK
}

int doLogs(const char *suffix)
{ 
   install("SECTION", "logs");

   if (streq(suffix, "/pracc.log"))
      cgiCopyVerbatim(PRACCLOG, "text/plain");
   else if (streq(suffix, "/pc.log"))
      cgiCopyVerbatim(PRACCPCLOG, "text/plain");
   else if (streq(suffix, "/pracc")) {
      if (streq(lookup("format", ""), "csv")) {
         char *s, *filter, *types;
         time_t tmin, tmax;

         if (parsedate(lookup("tmin", ""), &tmin)); else tmin = -1;
         if (parsedate(lookup("tmax", ""), &tmax)); else tmax = -1;
         if (tmax >= 0) tmax += 86399; // 23:59:59

         filter = lookup("filter", "");
         if (!filter[0]) filter = 0;

         types = lookup("types", "");
         if (!types[0]) types = 0;

         /* Print HTTP header and data */
         printf("Content-type: text/csv\r\n"); // see also RFC 2183
         printf("Content-disposition: attachment; filename=Log.csv\r\n\r\n");
         if (pracclog_dump(stdout, tmin, tmax, filter, types))
            printf("ERROR: %s\n", strerror(errno));
      }
      else {
         cgiStartHTML(TITLE);
         cgiCopyTemplate("pracclog.tmpl", 0);
         cgiEndHTML();
      }
d617 3
a619 28
   else if (streq(suffix, "/pclog")) {
      if (streq(lookup("format", ""), "csv")) {
         char *s, *filter;
         time_t tmin, tmax;

         if (parsedate(lookup("tmin", ""), &tmin)); else tmin = -1;
         if (parsedate(lookup("tmax", ""), &tmax)); else tmax = -1;
         if (tmax >= 0) tmax += 86399; // 23:59:59

         filter = lookup("filter", "");
         if (!filter[0]) filter = 0;

         /* Print HTTP header and data */
         printf("Content-type: text/csv\r\n"); // see also RFC 2183
         printf("Content-disposition: attachment; filename=pclog.csv\r\n\r\n");
         if (pclog_dump(stdout, tmin, tmax, filter) < 0)
            printf("ERROR: %s\n", strerror(errno));
      }
      else {
         cgiStartHTML(TITLE);
         cgiCopyTemplate("pclog.tmpl", 0);
         cgiEndHTML();
      }
   }
   else { // default
      cgiStartHTML(TITLE);
      cgiCopyTemplate("logs.tmpl", 0);
      cgiEndHTML();
a620 2
   return 0; // OK
}
d622 3
a624 21
int doCreate(const char *suffix)
{
   char *value, *limit, *acct;
   long thevalue, thelimit;
   int badacct, badvalue, badlimit;
   char *who, *comment;

   install("SECTION", "create");

   acct = lookup("acct", 0);
   badacct = acct && (praccCheckName(acct) != 0);
   install("badacct", (badacct) ? "" : 0);

   value = lookup("value", 0);
   badvalue = value && !parseamount(value, &thevalue);
   install("badvalue", (badvalue) ? "" : 0);

   limit = lookup("limit", 0);
   if (limit && streq(limit, "none")) {
      thelimit = UNLIMITED;
      badlimit = 0;
d626 2
a627 2
   else badlimit = limit && !parseamount(limit, &thelimit);
   install("badlimit", (badlimit) ? "" : 0);
d629 2
a630 2
   if (acct && !badacct && value && !badvalue && limit && !badlimit) {
      mode_t oldmask = umask(0117);
d632 1
a632 27
      comment = lookup("comment", 0);
      who = lookup("REMOTE_USER", lookup("USER", "?"));
      if (praccCreate(acct, thevalue, thelimit, who, comment, 0) == 0) {
         char buf[MAXLINE], s[16];

         /* Add log record */
         if (thelimit <= UNLIMITED) strcpy(s, "none");
         else snprintf(s, sizeof(s), "%ld", thelimit);
         snprintf(buf, sizeof(buf), "init %ld limit %s", thevalue, s);
         (void) praccLogup(who, acct, buf);

         install("status", "ok");
      }
      else {
         install("status", "fail");
         install("error", strerror(errno));
      }
      umask(oldmask);

      /* Reset fields */
      install("value", 0);
      install("limit", 0);
      install("comment", 0);
   }
   else install("status", 0);

   install("SECTION", "create");
d635 1
a635 1
   cgiCopyTemplate("create.tmpl", 0);
d637 1
a637 1
   
d641 1
a641 1
int doVars(const char *suffix)
a642 1
   install("SECTION", "vars");
d644 2
a645 1
   cgiCopyTemplate("vars.tmpl", 0);
d647 2
d766 6
a771 1
      if (*period) {
d775 4
a778 4
      else {
         if (parsedate(lookup("tmin", 0), &tmin)); else tmin = -1;
         if (parsedate(lookup("tmax", 0), &tmax)); else tmax = -1;
         if (tmax >= 0) tmax += 86399; // 23:59:59
d780 2
a1103 53

#if 0
/*
 * Return a unix timestamp that is before the given timestamp
 * (if NULL, current time) as specified by the period argument:
 */
time_t backdate(time_t *tp, const char *period)
{
   time_t now, then;
   struct tm tm;
   int n, days;

   assert(period);

   if (tp) now = *tp;
   else now = time(0);
   tm = *localtime(&now);
   tm.tm_isdst = 0;

   n = scanu(period, &days);
   if (n && (period[n] == '\0')) {
      tm.tm_sec = tm.tm_min = tm.tm_hour = 0;
      then = mktime(&tm);
      then -= days*24*60*60;
   }
   else if (streq(period, "year")) {
      tm.tm_mday = 1; // 1st of...
      tm.tm_mon = 0; // January
      tm.tm_sec = tm.tm_min = tm.tm_hour = 0;
      then = mktime(&tm);
   }
   else if (streq(period, "month")) {
      tm.tm_mday = 1; // 1st of month
      tm.tm_sec = tm.tm_min = tm.tm_hour = 0;
      then = mktime(&tm);
   }
   else if (streq(period, "week")) {
      days = tm.tm_wday;
      if (--days < 0) days = 6; // Mon=0
      tm.tm_sec = tm.tm_min = tm.tm_hour = 0;
      then = mktime(&tm);
      then -= days*24*60*60;
   }
   else if (streq(period, "all")) then = 0;
   else { // everything else means "today"
      tm.tm_sec = tm.tm_min = tm.tm_hour = 0;
      then = mktime(&tm);
   }

//fprintf(stderr, "backdate %s: %s", period, ctime(&then));//DEBUG
   return (then < 0) ? now : then;
}
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* Pracc Web GUI, $Revision$ */
d4 1
a55 1
void instdate(struct tm *tmp);
d59 3
a61 1
time_t backdate(time_t *tp, const char *period);
a136 7
#if 0
   /* Hack: always authorised on my box... XXX */
   {char buf[256];
   if (gethostname(buf, sizeof(buf)) == 0)
      if (streq(buf, "madrisa")) return;}
#endif

d172 5
a176 3
 * everybody is authorised to go to this page, but we
 * must make sure they watch only their own account(s)
 * using the praccGrant() API function.
a180 2
   long balance, limit;
   char class, buf[32];
a181 1
   struct tm *tmp;
d185 1
a185 1
   class = getacctinfo(acctname, &balance, &limit);
d190 1
a190 4
   if (tmp = localtime(&tmin))
      strftime(buf, sizeof(buf), "%Y-%m-%d", tmp);
   else strcpy(buf, "?");
   install("tmin", buf);
d193 1
a193 4
   if (tmp = localtime(&tmax))
      strftime(buf, sizeof(buf), "%Y-%m-%d", tmp);
   else strcpy(buf, "?");
   install("tmax", buf);
d249 4
d255 22
a276 1
   /* TODO */
d504 3
a506 5
         if (parsedate(lookup("dmin", ""), &tmin));
         else tmin = -1;

         if (parsedate(lookup("dmax", ""), &tmax)) tmax += 86400;
         else tmax = -1;
d531 3
a533 5
         if (parsedate(lookup("dmin", ""), &tmin));
         else tmin = -1;

         if (parsedate(lookup("dmax", ""), &tmax)) tmax += 86400;
         else tmax = -1;
d702 3
a704 7
      s = lookup("dmin", 0);
      if (s && parsedate(s, &tmin));
      else tmin = -1;

      s = lookup("dmax", 0);
      if (s && parsedate(s, &tmax)) tmax += 86400;
      else tmax = -1;
d724 3
a726 7
      s = lookup("dmin", 0);
      if (s && parsedate(s, &tmin));
      else tmin = -1;

      s = lookup("dmax", 0);
      if (s && parsedate(s, &tmax)) tmax += 86400;
      else tmax = -1;
d738 1
a738 1
      const char *period; // TODO
d749 3
a751 5
         if ((s = lookup("dmin", 0)) && parsedate(s, &tmin));
         else tmin = -1;

         if ((s = lookup("dmax", 0)) && parsedate(s, &tmax)) tmax += 86400;
         else tmax = -1;
d1064 13
d1118 1
d1127 1
@
