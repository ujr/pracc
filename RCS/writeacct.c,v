head	1.2;
access;
symbols;
locks
	ujr:1.2; strict;
comment	@ * @;


1.2
date	2006.10.14.12.02.24;	author ujr;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.14.07.35.33;	author ujr;	state Exp;
branches;
next	;


desc
@The pracc API call for appending pracc record,
i.e., a line to the pracc file format spec.
@


1.2
log
@Use the new praccpath() to obtain the absolute path
to a pracc file; no longer chdir(2) to the PRACCDIR.
@
text
@#include <assert.h>
#include <unistd.h>

#include "open.h"
#include "pracc.h"
#include "print.h"
#include "timestamp.h"

int writeacct(const char *account, int type, long number, const char *info)
{
  char buf[MAXLINE];
  char *bufptr, *bufend;
  char *path;
  int praccfd;

  assert(sizeof(buf) > 1+10+1+UTCSTAMPLEN+1); /* worst case mandatory part */

  switch (type) {
  	case '-': /* debit */ break;
  	case '+': /* credit */ break;
  	case '=': /* reset */ break;
  	case '$': /* limit */ break;
  	case '?': /* pracc error */ break;
  	case '!': /* print error */ break;
  	case '#': /* comment */ break;
  	default: abort(); /* BUG */
  }

  path = praccpath(account);
  if (path == 0) return -1; // ENOMEM
  praccfd = open_pracc(path);
  if (praccfd < 0) return -1;

  bufptr = buf;
  bufend = buf + sizeof(buf) - 1; /* reserve one byte for \n */
  bufptr += printc(bufptr, (char) type); /* debit, error, etc */
  if ((type == '$') && (number >= UNLIMITED)) bufptr += printc(bufptr, '*');
  else if (type != '#') bufptr += printu(bufptr, number); /* no num for # */
  bufptr += printc(bufptr, ' ');
  bufptr += timestamp(bufptr);
  bufptr += printc(bufptr, ' ');
  if (info) while ((bufptr < bufend) && *info) *bufptr++ = *info++;
  bufptr += printc(bufptr, '\n');
  
  /* append atomically: in just one write! */
  if (write(praccfd, buf, bufptr-buf) != bufptr-buf) return -1;
  if (close(praccfd) < 0) return -1;

  return SUCCESS;
}
@


1.1
log
@Initial revision
@
text
@a10 1
  int praccfd;
d13 2
d29 3
a31 2
  if (chdir(PRACCDIR) != 0) return -1;
  praccfd = open_pracc(account);
@
